////////////////////////////////////////////////////////////////////////
// Class:       ImageDivider
// Module Type: ImageDivider
// File:        ImageDivider_module.cc
//
// Generated at Thu Mar 31 09:36:00 2016 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "Geometry/Geometry.h" // LArCore
#include <cmath>
#include "TCanvas.h"
#include "TH2D.h"
#include "TBox.h"
#include "TLine.h"
#include "TROOT.h"

class ImageDivider;

class ImageDivider : public art::EDAnalyzer {
public:
  explicit ImageDivider(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  ImageDivider(ImageDivider const &) = delete;
  ImageDivider(ImageDivider &&) = delete;
  ImageDivider & operator = (ImageDivider const &) = delete;
  ImageDivider & operator = (ImageDivider &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void cross( double out[], double a[], double b[] );
  double cross2D( double a[], double b[] );

private:

  // Declare member data here.
  TCanvas* test;
  TH2D* bg;
  TBox* tpc;
  bool fTestDraw;
};


ImageDivider::ImageDivider(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  fTestDraw = false;
  
  test = new TCanvas("test","test", 1200, 600);
  bg = new TH2D("bg", "bg", 100, -10, 1050, 100, -120, 120 );
  tpc = new TBox( 0, -115, 1030, 117 );
  tpc->SetLineColor(kBlack);
  tpc->SetFillColor(0);
  tpc->SetLineWidth(1);
  test->Draw();
  bg->Draw();
  tpc->Draw();
}

void ImageDivider::cross( double out[], double a[], double b[] ) {
  out[0] = a[1]*b[2] - a[2]*b[1];
  out[1] = a[2]*b[0] - a[0]*b[2];
  out[2] = a[0]*b[1] - a[1]*b[0];
}

double ImageDivider::cross2D( double a[], double b[] ) {
  return a[0]*b[1] - a[1]*b[0];
}

void ImageDivider::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  art::ServiceHandle<geo::Geometry> geom;
  //geo::WireID wid = 
  //geo::WireGeo* pWire = geom->WirePtr( 
  // for ( geo::WireID const& wID : geom->IterateWireIDs() ) {
  //   geo::WireGeo const& Wire = geom->Wire( wID );
  //   std::cout << "[Wire ID " << wID << "]";
  //   double start[3];
  //   double end[3];
  //   Wire.GetStart( start );
  //   Wire.GetEnd( end );
  //   std::cout << " start (" << start[0] << ", " << start[1] << ", " << start[2] << ")  ";
  //   std::cout << " end (" << end[0] << ", " << end[1] << ", " << end[2] << ")";
  //   std::cout << std::endl;
  // }

  // We divide the image into certain number of segments in z and t (i.e. x)
  // Then we make an RGB image using only those wires that cross into that box
  // we expect to make about 50 images per event...
  
  int imgwidth=256;
  int tickstart = 400;
  int tickend   = 5800; // 5000 ticks (400+4600+400)
  // at 384 wires, that is 115.2 cm, 0.3 cm per wire
  // at 0.108 cm per usec, 1 wire pitch is 2.75 usec, this is 5-6 ticks
  int tickblock = 5; // 2.5 microseconds
  int ndsticks = (tickend-tickstart)/tickblock; // number of downsampled ticks
  
  // divisions for the Z-direction
  int ncolwires = geom->Nwires(2); // number of collection plane wires
  int nwire_divs = ncolwires/imgwidth;
  if ( ncolwires%imgwidth!=0 )
    nwire_divs+=1;
  float z0 = 0;

  // division for the Y-direction (233 cm across about)
  double pitch = 0.3;
  double imgwidth_cm = imgwidth*pitch;
  int ny     = 233/(pitch*imgwidth)+1;
  double y0 = -116.0;

  // division in time
  int nt_divs = ndsticks/imgwidth;
  if ( ndsticks%imgwidth!=0 )
    nt_divs+=1;

  //int nw = nwire_divs + (nwire_divs-1); // number of w-axis boxes
  //int nt = nt_divs + (nt_divs-1);       // number of t-axis boxes
  int nw = nwire_divs;
  int nt = nt_divs;

  std::cout << "Total number of boxes: " << nw*ny << " x nt = " << nw*ny*nt << std::endl;

  int largest_nwires =0;
  int nregions = 0;
  for ( int iw=0; iw<nw; iw++) {
    for (int iy=0; iy<ny; iy++) {

      //int worigin = iw*(imgwidth/2);
      //int yorigin = iy*(imgwidth/2);

      // define the four line segments that sets the boundary
      // do this by 4 rays.
      // start in lower right corner of box
      // direction vectors move counter-clockwise
      double seg0[4][2]; // set origins
      seg0[0][0] = y0;
      seg0[0][1] = z0;
      seg0[1][0] = y0;
      seg0[1][1] = z0 + pitch*imgwidth;
      seg0[2][0] = y0 + pitch*imgwidth;
      seg0[2][1] = z0 + pitch*imgwidth;
      seg0[3][0] = y0 + pitch*imgwidth;
      seg0[3][1] = z0;

      if ( fTestDraw ) {
	TBox* thisseg = new TBox( seg0[0][1], seg0[0][0], seg0[2][1], seg0[2][0] );
	thisseg->SetLineColor(kRed);
	thisseg->SetLineWidth(2);
	thisseg->Draw();
      }

      double dir[4][2] = { {0.0, 1.0},
			   {1.0, 0.0},
			   {0.0, -1.0},
			   {-1.0,0.0} }; // set dir vectors

      // std::cout << "Testing box" << std::endl;
      // std::cout << "(3:" << seg0[3][1] << "," << seg0[3][0] << ")"
      // 		<< "--(2:" << seg0[2][1] << "," << seg0[2][0] << ")" << std::endl;
      // std::cout << "|            |" << std::endl;
      // std::cout << "(0:" << seg0[0][1] << "," << seg0[0][0] << ")"
      // 		<< "--(1:" << seg0[1][1] << "," << seg0[1][0] << ")" << std::endl;
      
      // std::cout << "(3:" << dir[3][1] << "," << dir[3][0] << ")"
      // 		<< "--(2:" << dir[2][1] << "," << dir[2][0] << ")" << std::endl;
      // std::cout << "|            |" << std::endl;
      // std::cout << "(0:" << dir[0][1] << "," << dir[0][0] << ")"
      // 		<< "--(1:" << dir[1][1] << "," << dir[1][0] << ")" << std::endl;

      // length of segments is always imgwidth
      

      // now the fun begins, we test the intersection of wires with these line segments
      //int nintersect_wires_plane[3] = {0};
      std::vector<int> intersecting_plane_wires[3];
      int nwires = 0;
      for ( geo::WireID const& wID : geom->IterateWireIDs() ) {
	geo::WireGeo const& Wire = geom->Wire( wID );
	double start[3] = {0}; 
	double end[3] = {0};
	Wire.GetStart( start );
	Wire.GetEnd( end );
	// these return x,y,z

	// std::cout << "[Wire ID " << wID << "]";
	// std::cout << " start (" << start[2] << ", " << start[1] << ")  ";
	// std::cout << " end (" << end[2] << ", " << end[1] << ")";
	// std::cout << std::endl;
	
	// calculate wire direction
	double wiredir[2] = {0};
	double wirelen = 0.0;
	for (int v=0; v<2; v++) {
	  wiredir[v] = end[v+1]-start[v+1]; // we skip x
	  wirelen += wiredir[v]*wiredir[v];
	}
	wirelen = sqrt(wirelen);
	for (int v=0; v<2; v++)
	  wiredir[v] /= wirelen;

	// loop over each segment
	for (unsigned int s=0; s<4; s++) {

	  // calculate useful cross products
	  double qp[2] = {0};
	  double segdir[2] = {0};
	  double rxs[3] = {0};
	  double qpxr[3] = {0};
	  double qpxs[3] = {0};
	  for (unsigned int v=0; v<2; v++) {
	    qp[v] = start[v+1]-seg0[s][v];
	    segdir[v] = dir[s][v];
	  }
	  rxs[2] =  cross2D( segdir, wiredir );
	  qpxr[2] = cross2D( qp, segdir);
	  qpxs[2] = cross2D( qp, wiredir);

	  //std::cout << "rxs=" << rxs[2] << " qpxr=" << qpxr[2]  << " qpxs=" << qpxs[2] << std::endl;

	  // test if colinear
	  bool qpxr_zero = true;
	  bool rxs_zero = true;
	  for (int v=0; v<3; v++) {
	    if ( fabs(rxs[v])>1.0e-8 )
	      rxs_zero = false;
	    if ( fabs(qpxr[v])>1.0e-8 )
	      qpxr_zero = false;
	  }

	  if ( qpxr_zero && rxs_zero ) {
	    // colinear
	    //std::cout << " seg " << s << " is colinear" << std::endl;
	    continue;
	  }

	  // test if non-intersecting
	  if ( rxs_zero && !qpxr_zero ) {
	    //std::cout << " seg " << s << " is non-intersecting" << std::endl;
	    continue;
	  }

	  // rays intersect
	  double u,t;
	  if ( rxs[2]!=0 ) {
	    u = qpxr[2]/rxs[2];
	    t = qpxs[2]/rxs[2];
	  }
	  else {
	    u = -1;
	    t = -1;
	  }

	  //std::cout << "u=" << u << " t=" << t << std::endl;

	  if ( u>=0 && u<=wirelen && t>=0 && t<=imgwidth_cm ) {
	    //std::cout << " seg " << s << " intersects" << std::endl;
	    if ( fTestDraw ) {
	      TLine* l = new TLine( start[2], start[1], end[2], end[1] );
	      l->Draw();
	    }
	    nwires++;
	    intersecting_plane_wires[ wID.Plane ].push_back( wID.Wire );
	    continue;
	  }

	  //std::cout << " seg " << s << " neither intersects nor is parallel" << std::endl;
	  
	  
	}
	
	//std::cin.get();

      }

      std::cout << "Region number of wires. Plane0=" << intersecting_plane_wires[0].size()
		<< " Plane1=" << intersecting_plane_wires[1].size() 
		<< " Plane2=" << intersecting_plane_wires[2].size()
		<< std::endl;
      if ( (int)intersecting_plane_wires[0].size()>largest_nwires )
	largest_nwires = intersecting_plane_wires[0].size();
      if ( (int)intersecting_plane_wires[1].size()>largest_nwires )
	largest_nwires = intersecting_plane_wires[1].size();
      if ( (int)intersecting_plane_wires[2].size()>largest_nwires )
	largest_nwires = intersecting_plane_wires[2].size();
      //for (int it; it<nt; it++) {
      //int torigin = it*tickblock*(imgwidth/2);
      //}
      //break;
      nregions++;
    }
    //break;
  }

  std::cout << "Number of regions defined: " << nregions << std::endl;
  std::cout << nw << "x" << ny << "x" << nt << std::endl;
  std::cout << "Largest number of wires needed inside of a region: " << largest_nwires << std::endl;
  std::cout << "Raw Memory per event: " << largest_nwires*largest_nwires*nw*ny*nt*2/1.0e6 << " MB" << std::endl;

  test->SaveAs("test.png");
}

DEFINE_ART_MODULE(ImageDivider)
