////////////////////////////////////////////////////////////////////////
// Class:       BNBCosmics
// Module Type: analyzer
// File:        BNBCosmics_module.cc
//
// Generated at Wed Dec 30 15:55:44 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

/*
  The YOLO module behaves slightly differently than the Supera module,
    at least enough to warrant an experimental module.
    
  YOLO does a fix crop of an image and downsamples it to 448x448 (the input for the darknet yolo network)
  It does a fix crop (specified in FCL file) of the entire event and finds the bounding boxes for interactions.
  It scales the above down to a 448x448 image.
  Along with the image, bounding boxes around the different interactions are found.
  All of this is saved in a ROOT file, which stores MCTruth info, the bounding box info, and the image itself.
  Scripts can be used to augment and manipulate this data.
  A script will also be used to output the data in the format YOLO wants, which is a folder of images, a text file
    with the names of the images, and a folder of text files with the label and bounding box information.
 */

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <limits>
#include <climits>
#include <set>

#include <TStopwatch.h>

#include "Geometry/Geometry.h" //LArCore
#include "Utilities/DetectorProperties.h" // LArData
#include "Utilities/LArProperties.h"
#include "RawData/RawDigit.h" // LArData
#include "Simulation/SimChannel.h" // LArSim
#include "SimulationBase/GTruth.h" // NuTools
#include "SimulationBase/MCTruth.h" // NuTools
#include "SimulationBase/MCNeutrino.h" // NuTools
#include "MCBase/MCTrack.h" // LArData
#include "MCBase/MCShower.h" // LArData

#include "ConverterAPI.h"
#include "SuperaCore/lmdb_converter.h"
#include "Cropper.h"
#include "LArCaffe/larbys.h"
#include "LArCaffe/LArCaffeUtils.h"
#include "FilterBase.h"
#include "ImageExtractor.h"
#include "MCParticleTree.h"

#include "TTree.h" // ROOT

const size_t LMDB_MAP_SIZE = 1099511627776;  // 1 TB

class BNBCosmics;

class BNBCosmics : public art::EDAnalyzer {
public:
  explicit BNBCosmics(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  BNBCosmics(BNBCosmics const &) = delete;
  BNBCosmics(BNBCosmics &&) = delete;
  BNBCosmics & operator = (BNBCosmics const &) = delete;
  BNBCosmics & operator = (BNBCosmics &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();
  void finalize();
  
public:

  enum TimeProfCategory_t {
    kIO_LARSOFT,
    kIO_CROPPER,
    kIO_STORAGE,
    kANALYZE_TOTAL,
    kTIMEPROFCATEGORYMAX
  };

private:

  std::vector<larcaffe::RangeArray_t> setEventCrop(const art::Event& e);
  std::vector<larcaffe::RangeArray_t> findBoundingBoxes(const art::Event& e);
  void getMCTruth( art::Event const & e );
  void clearBoundingBoxes();

  // ----------------------------------------------------------------------
  // fichl parameters
  bool fCropInteractions; //< crop interactions into their own image
  std::vector<bool> _plane_enable_v; //< which planes to extract images for
  std::string fImageSource; //< [RawDigits, Wire, Hit]
  fhicl::ParameterSet fProducers; // name of producers
  bool fSkipNeutrons;

  ::larcaffe::RangeArray_t _wiretime_range_hard_v; //< ranges for (planes,...,time ticks)

  ::larcaffe::supera::Cropper _cropper; //< cropper for the entire event
  ::larcaffe::supera::Cropper _cropper_interaction; //< cropper for the interactions
  ::larcaffe::logger _logger; //< output logger

  std::vector<std::string> _producer_v; //< name of producers
  std::vector<double> _time_prof_v; //< stores times of different steps
  double _event_counter; 
  std::vector< larcaffe::supera::FilterBase* > _filter_list; //< list of image filters (not really used)

  // ----------------------------------------------------------------------
  // ROOT tree members
  void setupTrees( int nplanes );

  TTree* m_ImageTree; //< whole image crop
  TTree* m_BBTree;    //< interaction image crop
  std::vector<int>** m_planeImages; //< [planeid][row-major 2D image]
  int m_event; //< event ID
  int m_subrun; //< subrun ID
  int m_run; //< run ID
  int m_nfilledboxes;
  float m_Enu; //< neutrino energy (0 if cosmic)
  std::vector<float> m_vertex;
  std::vector<int> m_vertex_tw;
  int m_mode; //< interaction mode (-1 if cosmic)
  int m_nuscatter; // neutrino scattering code
  int m_flavor; //< neutrino flavor (-1 if cosmic)
  int m_interaction; //< neutrino interaction type (-1 cosmics)
  int m_nticks; //< image height in time ticks
  int* m_wires;  //< image width in wires [planeid]
  int fNPlanes; //< number of wire planes
  bool fUseWire;
  bool fGroupAllInteractions;
  bool fUseSimChannel;
  bool fCosmicsMode;
  bool fSingleParticleMode;
  std::string singlepname;

  // bounding boxes: stuck doing this because want to make flat branch tree
  
  // for events
  std::vector<int>** m_plane_bb_loleft_t;
  std::vector<int>** m_plane_bb_loleft_w;
  std::vector<int>** m_plane_bb_hileft_t;
  std::vector<int>** m_plane_bb_hileft_w;
  std::vector<int>** m_plane_bb_loright_t;
  std::vector<int>** m_plane_bb_loright_w;
  std::vector<int>** m_plane_bb_hiright_t;
  std::vector<int>** m_plane_bb_hiright_w;
  std::vector<std::string>* m_bbox_label;
  std::vector<int>** m_bb_planeImages;
  char m_label[50];

  // for individual bounding boxes
  int* m_plane_bbinteraction_loleft_t;
  int* m_plane_bbinteraction_loleft_w;
  int* m_plane_bbinteraction_hiright_t;
  int* m_plane_bbinteraction_hiright_w;
  char m_bblabel[100];
  int m_bb_nticks;
  int m_bb_nwires;
  
  std::vector< std::string > m_interaction_list; ///< labels for bounding boxes


};

BNBCosmics::BNBCosmics(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _logger("BNBCosmics")
  , _time_prof_v(kTIMEPROFCATEGORYMAX,0.)
  , _event_counter(0)
{
  // ------------------------------------------------
  // DETERMINE CONSTANTS

  // set number of planes
  art::ServiceHandle<geo::Geometry> geom;
  fNPlanes = geom->Nplanes();

  // ------------------------------------------------
  // FICHL PARAMETERS
  
  // set verbosity
  ::larcaffe::msg::Level_t vlevel = (larcaffe::msg::Level_t)(p.get<unsigned short>("Verbosity",1));
  _logger.set(vlevel);
  _cropper.set_verbosity(vlevel);

  // set active planes
  _plane_enable_v = p.get<std::vector<bool> >("EnablePlane");
  if(_plane_enable_v.size() != geom->Nplanes()) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "EnablePlane parameter must be length " << geom->Nplanes() << " (# of planes) boolean array!" << std::endl;
    throw ::larcaffe::larbys();
  }

  // crop interactions
  fCropInteractions = p.get<bool>( "CropInteractions", false );
  
  // store producers
  fProducers = p.get<fhicl::ParameterSet>("Producers");
  _producer_v.resize(3,"");
  _producer_v[0] = fProducers.get<std::string>("RawDigit");
  _producer_v[1] = fProducers.get<std::string>("Wire");
  _producer_v[2] = fProducers.get<std::string>("Hit");
  if(_producer_v.size()!=3) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Producers parameter must be length 3 string array (producer names for raw digit, wire, and hit respectively)!" << std::endl
      << "Leave empty string to skip using specific product. An array of 3 empty strings will also cause this message!" << std::endl;
    throw ::larcaffe::larbys();
  }
  _logger.LOG(::larcaffe::msg::kNORMAL,__FUNCTION__,__LINE__)
    << "Using data producers: (RawDigit, Wire, Hit) = (" 
    << _producer_v[0] <<", " <<  _producer_v[1] << ", " << _producer_v[2] << ")" << std::endl;

  // Image Source
  fImageSource = p.get<std::string>("ImageSource");
  if ( fImageSource!="RawDigit" && fImageSource!="Wire" && fImageSource!="Hit" ) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected Image source, " << fImageSource << ". choices: RawDigit, Wire, Hit." << std::endl;
    throw ::larcaffe::larbys();    
  }

  // cropper hard limit (dependent on cropper params)
  std::vector<std::pair<int,int> > range_v = p.get<std::vector<std::pair<int,int> > >("HardLimitRange");
  if(range_v.size() != (geom->Nplanes() + 1)) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "HardLimitRange must be length " << geom->Nplanes() + 1 << " (wire plane count + 1 for time)!" << std::endl;
    throw ::larcaffe::larbys();
  }
  _wiretime_range_hard_v.resize( range_v.size() );
  for(size_t plane=0; plane<range_v.size(); ++plane) {
    if ( range_v.at(plane).first<0 ) {
      // unspecified
      if ( (int)plane<fNPlanes ) {
	// unspecified wires: we take all of them (that will fit in multiple of target size)
	_wiretime_range_hard_v.at(plane).first = 0;
	int nfactors = (geom->Nwires(plane))/_cropper.TargetWidth();
	_wiretime_range_hard_v.at(plane).second = nfactors*_cropper.TargetWidth() - 1;
	// maybe i shuld center this
      }
      else {
	_logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Time ticks need hard range" << std::endl;
	throw ::larcaffe::larbys();
      }
    }
    else {
      // specified range
      _wiretime_range_hard_v.at(plane).first  = (unsigned int)range_v.at(plane).first;
      _wiretime_range_hard_v.at(plane).second = (unsigned int)range_v.at(plane).second;
    }
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
      << "setting hard limit for plane=" << plane 
      << ": " << _wiretime_range_hard_v.at(plane).first << " " << _wiretime_range_hard_v.at(plane).second << std::endl;
  }

  // cropper parameters
  fhicl::ParameterSet cropper_params = p.get<fhicl::ParameterSet>("EventCropperConfig");
  fhicl::ParameterSet interaction_cropper_params = p.get<fhicl::ParameterSet>("InteractionCropperConfig");

  // crop interactions
  fSkipNeutrons = p.get<bool>( "SkipNeutrons", false );


  // ------------------------------------------------------
  // Configure Croppers

  // event cropper parameters
  std::vector<unsigned int> cropper_config;
  cropper_config.push_back( cropper_params.get< unsigned int >( "TimePadding" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "WirePadding" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "TimeTargetSize" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "WireTargetSize" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "CompressionFactor" ) );
  if(cropper_config.size()==5){
    // we got them all. setup the cropper.
    _cropper.configure(cropper_config[0],
		       cropper_config[1],
		       cropper_config[2],
		       cropper_config[3],
		       cropper_config[4]);
  }else{
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected length of event cropper configuration (length=" << cropper_config.size() 
      << ") ... must be length 5 unsigned int array" << std::endl;
    throw ::larcaffe::larbys();
  }

  // interaction cropper config
  cropper_config.clear();
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "TimePadding" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "WirePadding" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "TimeTargetSize" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "WireTargetSize" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "CompressionFactor" ) );
  if(cropper_config.size()==5){
    // we got them all. setup the cropper.
    _cropper_interaction.configure(cropper_config[0],
				   cropper_config[1],
				   cropper_config[2],
				   cropper_config[3],
				   cropper_config[4]);
  }else{
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected length of interaction cropper configuration (length=" << cropper_config.size() 
      << ") ... must be length 5 unsigned int array" << std::endl;
    throw ::larcaffe::larbys();
  }
  
  // setup filters: can remove images
  std::vector<std::string> filter_names = p.get< std::vector<std::string> >( "ImageFilters" );
  fhicl::ParameterSet filter_params = p.get< fhicl::ParameterSet >( "FilterConfigs" );
  for ( std::vector<std::string>::iterator it_string=filter_names.begin(); it_string!=filter_names.end(); it_string++ ) {
    std::string filter_name = *it_string;
    ::larcaffe::supera::FilterBase* filter = ::larcaffe::supera::FilterFactory::get()->create( filter_name );
    fhicl::ParameterSet params = filter_params.get< fhicl::ParameterSet >( filter_name );
    filter->configure( params );
    _filter_list.emplace_back( filter );
  }
  
  // setup output Trees
  setupTrees( fNPlanes );
  
  
}
			   
void BNBCosmics::beginJob() {
}

std::vector<larcaffe::RangeArray_t> BNBCosmics::setEventCrop(const art::Event& e) 
{
  // sets the fixed range as the crop range
  art::ServiceHandle<geo::Geometry> geom;

  std::vector<larcaffe::RangeArray_t> image_v;

  // the fixed crop
  image_v.push_back( _wiretime_range_hard_v );
  
  return image_v;
}

std::vector<larcaffe::RangeArray_t> BNBCosmics::findBoundingBoxes(const art::Event& e) 
{
  // we group tracks belong to same interaction and make a bounding box for it
  // we need to group cosmic rays and neutrino interactions
  // the hardest part of this code

  art::ServiceHandle<geo::Geometry> geom;

  std::vector<larcaffe::RangeArray_t> image_v;

  TStopwatch fWatch; fWatch.Start();
  art::Handle<std::vector<sim::MCTrack> > mctHandle;
  e.getByLabel("mcreco",mctHandle);
  _time_prof_v[kIO_LARSOFT] += fWatch.RealTime();
  if(!mctHandle.isValid()) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Missing MCTrack info (cannot make image-per-interaction)!" << std::endl;
    throw ::larcaffe::larbys();
  }
  art::Handle<std::vector<sim::MCShower>> mcshHandle;
  e.getByLabel("mcreco",mcshHandle);
  if(!mcshHandle.isValid()) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Missing MCShower info (cannot make image-per-interaction)!" << std::endl;
    throw ::larcaffe::larbys();
  }


  // create sets of interactions

  // find particle ID of primaries of neutrino interaction
  std::map<unsigned int,std::vector<sim::MCTrack> > nu_interaction_tracks;
  std::map<unsigned int,std::vector<sim::MCShower> > nu_interaction_showers;

  // dump neutrino
  art::Handle< std::vector<simb::MCTruth> > gentruth;
  e.getByLabel( "generator", gentruth );
  // validity check should go here
  const std::vector<simb::MCTruth>& genie = *gentruth;
  for (int i=0; i<genie.at(0).NParticles();i++) {
    std::cout << genie.at(0).GetParticle(i) << std::endl;
  }
  

  // start with tracks
  std::map<unsigned int,std::vector<sim::MCTrack> > interaction_m;

  for(auto const& mct : *mctHandle) {
    
    std::cout << "mctrack: id=" << mct.TrackID() << " pdg=" << mct.PdgCode() << " " << mct.Process() << " ancestor=" << mct.AncestorTrackID()  << std::endl;
    // we skip the neutrons
    if ( fSkipNeutrons && mct.PdgCode()==2112 )
      continue;

    auto iter = interaction_m.find(mct.AncestorTrackID());
    // if no ancestor found, add it to map
    if( iter == interaction_m.end() )
      iter = interaction_m.emplace(mct.AncestorTrackID(),std::vector<sim::MCTrack>()).first;
    
    // otherwise, add it to the vector of mctracks
    (*iter).second.push_back(mct);
  }
  _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Made " << interaction_m.size() << " interaction groups to crop around" << std::endl;

  // get shower info
  std::set< unsigned int > decaytracks; // decay information
  std::map<unsigned int,std::vector<sim::MCShower> > shower_m;
  shower_m.emplace( 0, std::vector<sim::MCShower>() );
  for(auto const& mcsh : *mcshHandle) {
    std::cout << "mcshower: id=" << mcsh.TrackID() << " pdg=" << mcsh.PdgCode() << " " << mcsh.Process() << " ancestor=" << mcsh.AncestorTrackID()  << std::endl;
    // look for decays
    if ( std::string(mcsh.Process())=="Decay" ) {
      auto ittrack=interaction_m.find( mcsh.AncestorTrackID() );
      if ( ittrack!=interaction_m.end() ) {
	// matching
	decaytracks.insert( mcsh.AncestorTrackID() );
      }
    }
    // load all showers in neutrino mode
    if ( fGroupAllInteractions ) {
      auto iter = shower_m.find(0);
      (*iter).second.push_back(mcsh);
    }
  }

  // Parse Shower and Track info and bundle them by ancestor
  larbys::supera::MCParticleTree particletree( *mctHandle, *mcshHandle );
  particletree.parse();
  particletree.boom();

  //   // now find bounding box of each interaction
  //   m_interaction_list.clear();
  //   for(auto const& int_pair : interaction_m) {
    
  //     auto range_array = _cropper_interaction.Format(_cropper_interaction.WireTimeBoundary(int_pair.second, shower_m[0]));

  //     // determine what the interaction is
  //     std::stringstream ss;
  //     if ( fSingleParticleMode ) {
  // 	ss << singlepname;
  //     }
  //     else if ( fCosmicsMode ){
  // 	const sim::MCTrack& mct0 = int_pair.second.at(0);
  // 	if ( std::abs(mct0.PdgCode())==13 ) {
  // 	  // muon
  // 	  ss << "cosmic_muon";
  // 	  if ( int_pair.second.size()>1 ) {
  // 	    auto itmatch = decaytracks.find( int_pair.first );
  // 	    if ( itmatch!=decaytracks.end() )
  // 	      ss << "_decay";
  // 	  }//end of if not single muon only
  // 	}//end of if muon
  // 	else if ( std::abs(mct0.PdgCode())==2212 )  {
  // 	  ss << "cosmic_proton";
  // 	}
  // 	else if ( std::abs(mct0.PdgCode())==11 ) {
  // 	  ss << "cosmic_shower";
  // 	}
  // 	else 
  // 	  ss << "cosmic_other";
  //     }//end of if cosmics
  //     else {
  // 	// neutrino mode
  // 	ss << "neutrino_mode" << m_mode << "_flux" << m_flavor;
  //     }

  //     m_interaction_list.push_back( ss.str() );

  //     auto const& time_range = range_array.back();
    
  //     for( size_t plane=0; plane < geom->Nplanes(); ++plane ) {

  // 	auto const& wire_range = range_array[plane];

  // 	if(wire_range.first < wire_range.second && time_range.first < time_range.second) {
	
  // 	  image_v.push_back(range_array);

  // 	  break;
	
  // 	}
      
  //     }
    
  //   }//end of interaction loop
  // }//end of if not group all interactions

  return image_v;
}//end of findboundingboxes
	
void BNBCosmics::getMCTruth( art::Event const & e ) {
  // Sets the MC truth variables to be stored in m_ImageTree
  
  // GENIE data to get interaction mode and neutrino energy if possible
  art::Handle< std::vector<simb::MCTruth> > gentruth;
  e.getByLabel( "generator", gentruth );
  if ( fCosmicsMode || fSingleParticleMode || !gentruth.isValid() ) {
    _logger.LOG(::larcaffe::msg::kINFO, __FUNCTION__,__LINE__) << "No GENIE Truth. Must be Cosmic Event" << std::endl;
    m_flavor = -1;
    m_mode = -1;
    m_interaction = -1;
    m_nuscatter = -1;
    m_Enu = 0.0;
    const std::vector<simb::MCTruth>& genie = *gentruth;
    m_Enu = genie.at(0).GetParticle(0).E();
    m_vertex.resize(4, 0.0 );
    m_vertex.at(0) = genie.at(0).GetParticle(0).Vx();
    m_vertex.at(1) = genie.at(0).GetParticle(0).Vy();
    m_vertex.at(2) = genie.at(0).GetParticle(0).Vz();
    m_vertex.at(3) = genie.at(0).GetParticle(0).T();

  }
  else {
  
    const std::vector<simb::MCTruth>& genie = *gentruth;
    if ( genie.size()!=1 ) {
      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Unexpected number of MCTruth objects = " << genie.size() << std::endl;
      if ( genie.size()==0)
	throw ::larcaffe::larbys();
    }
    m_mode = genie.at(0).GetNeutrino().Mode();
    m_nuscatter = genie.at(0).GetNeutrino().CCNC();
    m_interaction = genie.at(0).GetNeutrino().InteractionType();
    m_flavor = genie.at(0).GetNeutrino().Nu().PdgCode();
    
    // Get neutrino energy
    m_Enu = genie.at(0).GetNeutrino().Nu().E();

    // Get Vertex
    m_vertex.resize(4, 0.0);
    m_vertex.at(0) = genie.at(0).GetParticle(0).Vx();
    m_vertex.at(1) = genie.at(0).GetParticle(0).Vy();
    m_vertex.at(2) = genie.at(0).GetParticle(0).Vz();
    m_vertex.at(3) = genie.at(0).GetParticle(0).T();

  }

  // Get Vertex in terms of time and wire
  art::ServiceHandle<geo::Geometry> geom;
  art::ServiceHandle<util::LArProperties> larp;
  art::ServiceHandle<util::TimeService> ts;
  //art::ServiceHandle<util::DetectorProperties> detp;
  const double drift_velocity = larp->DriftVelocity()*1.0e-3; // make it cm/ns                                                                                                                     
  //const int tick_max = detp->NumberTimeSamples();

  m_vertex_tw.resize(geom->Nplanes()+1,0);
  for (size_t iplane=0; iplane<geom->Nplanes(); iplane++) {
    geo::WireID wire_id;
    try {
      wire_id = geom->NearestWireID(m_vertex.data(), iplane);
    }
    catch (geo::InvalidWireIDError& err) {
      //std::cout << "out of bounds. using better number" << std::endl;
      wire_id.Wire = err.better_wire_number;
    }
    m_vertex_tw.at(iplane) = wire_id.Wire;
  }  
  int tick = (int)(ts->TPCG4Time2Tick(m_vertex.at(3) + (m_vertex.at(0) / drift_velocity))) + 1;
  m_vertex_tw.at(3) = tick;
  
}
  


void BNBCosmics::analyze(art::Event const & e)
{
  TStopwatch pWatchAnalyze,pWatchDB,pWatchDatum,pWatchLArIO;
  pWatchAnalyze.Start();
  
  // Implementation of required member function here.
  if(_logger.debug())
    _logger.LOG(::larcaffe::msg::kDEBUG,__FUNCTION__,__LINE__) << "Load RawDigits Handle" << std::endl;
  
  //
  // Determine region size
  //
  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Extracting image array" << std::endl;
  auto region_v = setEventCrop(e);
  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Extracted " << region_v.size() << " images!" << std::endl;
  
  // Event Code
  m_event  = (int)e.event();
  m_run    = (int)e.run();
  m_subrun = (int)e.subRun();
  
  // Get MC Truth
  //getMCTruth( e );
  
  // // Label
  // if ( fSingleParticleMode )
  //   sprintf(m_label, "%s_%d_%d_%d", singlepname.c_str(), m_run, m_subrun, m_event );
  // else if ( fCosmicsMode )
  //   sprintf(m_label, "cosmics_%d_%d_%d", m_run, m_subrun, m_event );
  // else
  //   sprintf(m_label, "nu_%d_%d_%d_mode_%d", m_run, m_subrun, m_event, m_mode );
  
  //
  // Save region image and bounding boxes
  //
  // art::ServiceHandle<geo::Geometry> geom;
  
  
  // if(!_producer_v[0].empty()) {
  //   if(_logger.info())
  //     _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Saving RawDigit... " << std::endl;
    
  //   pWatchLArIO.Start();
  //   art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  //   art::Handle< std::vector<recob::Wire> > wireVecHandle;
  //   if ( fUseWire )
  //     e.getByLabel(_producer_v[1], wireVecHandle );
  //   else
  //     e.getByLabel(_producer_v[0], digitVecHandle);
  //   _time_prof_v[kIO_LARSOFT] += pWatchLArIO.RealTime();
    
  //   if ( fUseWire ) {
  //     if ( !wireVecHandle.isValid() ) {// no rawdigits 
  // 	_logger.LOG(::larcaffe::msg::kWARNING,__FUNCTION__,__LINE__) 
  // 	  << "Missing Wires by " << _producer_v[1] << " Skipping." << std::endl;
  // 	return;
  //     }
  //     else if ( wireVecHandle->empty() ) // empty rawdigits
  // 	_logger.LOG(::larcaffe::msg::kWARNING,__FUNCTION__,__LINE__) << "Empty Wire info. skipping." << std::endl;
  //     else {
  // 	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
  // 	  << "Extracting " << region_v.size() << " images for Wire " << std::endl;
  //     }
  //   }
  //   else {
  //     if ( !digitVecHandle.isValid() ) { // no rawdigits
  // 	_logger.LOG(::larcaffe::msg::kWARNING,__FUNCTION__,__LINE__) 
  // 	  << "Missing RawDigits by " << _producer_v[0] << " Skipping." << std::endl;
  // 	return;
  //     }
  //     else if ( digitVecHandle->empty() ) // empty rawdigits
  // 	_logger.LOG(::larcaffe::msg::kWARNING,__FUNCTION__,__LINE__) << "Empty RawDigits info. skipping." << std::endl;
  //     else {
  // 	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
  // 	  << "Extracting " << region_v.size() << " images for RawDigit " << std::endl;
  //     }
  //   }
    
    // // clear bounding boxes
    // clearBoundingBoxes();
    // // place to store image scale-down, if any
    // std::vector<int> plane_compression;
    // plane_compression.resize(fNPlanes+1,1);
    
    // // Make an extractor
    // larcaffe::supera::ImageExtractor extractor;
    
    // // loop through cropping regions (should only be one for BNBCosmics Module)
    // for(size_t range_index=0; range_index < region_v.size(); ++range_index) {
      
    //   auto const& range_v = region_v[range_index];
      
    //   auto const& time_range = range_v.back();
      
    //   for(size_t plane=0; plane < geom->Nplanes(); ++plane) {
	
    // 	auto const& wire_range = range_v[plane];
    // 	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__, __LINE__) << "fill wire range " << wire_range.first << " " << wire_range.second << std::endl;
	
    // 	if(wire_range.first == wire_range.second && time_range.first == time_range.second) continue;
	
    // 	// copy data into image
    // 	larcaffe::Image img;
    // 	if ( fUseWire )
    // 	  img = extractor.Extract( plane, wire_range, time_range, *wireVecHandle );
    // 	else
    // 	  img = extractor.Extract( plane, wire_range, time_range, *digitVecHandle );
	
    // 	m_nticks = time_range.second-time_range.first+1;
    // 	m_wires[plane]  = wire_range.second-wire_range.first+1;
	
    // 	//check image
    // 	// std::cout << "[Check Pre-Compressed Image]" << std::endl;
    // 	// for (int t=0; t<(int)(time_range.second-time_range.first+1);t++) {
    // 	//   std::cout << img.pixel( t, 1 ) << " ";
    // 	// }
    // 	// std::cout << std::endl;
	
    // 	// filter: add the ability to reject images
    // 	// bool keep = true;
    // 	// for ( std::vector< larcaffe::supera::FilterBase* >::iterator it_filters=_filter_list.begin(); it_filters!=_filter_list.end(); it_filters++ ) {
    // 	//   if( !(*it_filters)->doWeKeep( *db ) ) {
    // 	//     keep = false;
    // 	//     break;
    // 	//   }
    // 	// }
    // 	// if ( !keep ) {
    // 	//   continue;
    // 	//}
	
    // 	// compress image
    // 	if ( _cropper.TargetWidth() < img.width() || _cropper.TargetHeight() < img.height() ) {
    // 	  plane_compression[plane] = img.width()/_cropper.TargetWidth();
    // 	  plane_compression[fNPlanes] = img.height()/_cropper.TargetHeight();
    // 	  img.compress( _cropper.TargetHeight(), _cropper.TargetWidth(), larcaffe::Image::kMaxPool );
    // 	}
	
    // 	// also need to transform vertex_tw into (time,wire) coordinates of this cropped image (filled already in getMC above)
    // 	m_vertex_tw.at(plane) = (int)(m_vertex_tw.at(plane)-wire_range.first)/plane_compression[plane];

    // 	// std::cout << "[Check Compressed Image]" << std::endl;
    // 	// for (int t=0; t<(int)(img.height());t++) {
    // 	//   std::cout << img.pixel( t, 1 ) << " ";
    // 	// }
    // 	// std::cout << std::endl;
	
	
    // 	// transfer image to ROOT variables
    // 	m_planeImages[plane]->resize( img.height()*img.width() );
    // 	for ( int w=0; w<(int)img.width(); w++) {
    // 	  for (int t=0; t<(int)img.height(); t++) {
    // 	    m_planeImages[plane]->at( img.height()*w + t ) = (int)img.pixel( t, w );
    // 	  }
    // 	}
	
    // 	// std::cout << "[Check Plane Image]" << std::endl;
    // 	// for (int t=0; t<(int)(img.height());t++) {
    // 	//   std::cout << m_planeImages[plane]->at( img.height()*1+t);
    // 	// }
    // 	// std::cout << std::endl;	      
	
	
    // 	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) <<"image " << range_index << " @ " << plane << " extracted..." << std::endl;
    //   }//end of loop over planes
      
    //   // convert time coordinate
    //   m_vertex_tw.at(fNPlanes) = (int)(m_vertex_tw.at(fNPlanes)-time_range.first)/plane_compression[fNPlanes];
      
    // }// end of image crop ranges
    
    //
    // Determine bounding boxes
    //

  auto bboxes = findBoundingBoxes(e); //<<<<<<<<


    // each interaction has bounding boxes in each plane
  //   auto const& the_range_v = region_v[0];
    
  //   int ibox = -1;
  //   m_nfilledboxes = 0;
  //   for ( auto const& range : bboxes ) {
  //     // range is a RangeArray_t which is a vector< pair<int,int> >
  //     // (x,y) = (wire, time 0toX)
  //     ibox++;
      
  //     // stay within bounds
  //     if ( range[fNPlanes].second<the_range_v[fNPlanes].first 
  // 	   || range[fNPlanes].first>the_range_v[fNPlanes].second )
  // 	continue;
      
  //     // calculate time bounds in cropped images coordinates
  //     int t_lo = (int)range[fNPlanes].first  - (int)the_range_v[fNPlanes].first;
  //     int t_hi = (int)range[fNPlanes].second - (int)the_range_v[fNPlanes].first;
      
  //     // enforce time bounds
  //     t_lo = std::max( t_lo, 0 );
  //     t_hi = std::min( t_hi, (int)the_range_v[fNPlanes].second-(int)the_range_v[fNPlanes].first );
      
  //     for (int plane=0; plane<fNPlanes; plane++) {

  // 	// need to account for compression
  // 	// bounding box goes counter clockwise from origin
	
  // 	int w_lo = (int)range[plane].first  - (int)the_range_v[plane].first;
  // 	int w_hi = (int)range[plane].second - (int)the_range_v[plane].first;
	
  // 	// enforce image bounds
  // 	w_lo = std::max( w_lo, 0 );
  // 	w_hi = std::min( w_hi, (int)the_range_v[plane].second-(int)the_range_v[plane].first);
	
  // 	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
  // 	  << "[Plane " << plane << " BBOX]"
  // 	  << " t=[" << (int)the_range_v[fNPlanes].first+t_lo << ", " << (int)the_range_v[fNPlanes].first+t_hi << "]"
  // 	  << " w=[" << (int)the_range_v[plane].first+w_lo << ", " << (int)the_range_v[plane].first+w_hi << "]"
  // 	  << " image bound: t=[" << the_range_v[fNPlanes].first << ", " << the_range_v[fNPlanes].second <<"]"
  // 	  << " w=[" << the_range_v[plane].first << ", " << the_range_v[plane].second << "]" << std::endl;

  // 	m_plane_bb_loleft_t[plane]->push_back( t_lo/plane_compression[fNPlanes] );
  // 	m_plane_bb_loleft_w[plane]->push_back( w_lo/plane_compression[plane] );

  // 	m_plane_bb_loright_t[plane]->push_back( t_lo/plane_compression[fNPlanes] );
  // 	m_plane_bb_loright_w[plane]->push_back( w_hi/plane_compression[plane] );

  // 	m_plane_bb_hiright_t[plane]->push_back( t_hi/plane_compression[fNPlanes] );
  // 	m_plane_bb_hiright_w[plane]->push_back( w_hi/plane_compression[plane] );

  // 	m_plane_bb_hileft_t[plane]->push_back( t_hi/plane_compression[fNPlanes] );
  // 	m_plane_bb_hileft_w[plane]->push_back( w_lo/plane_compression[plane] );

  // 	// save image for bbox
  // 	larcaffe::Image bbimg;
  // 	if ( fUseWire )
  // 	  bbimg = extractor.Extract( plane, range[plane], range[fNPlanes], *wireVecHandle );
  // 	else
  // 	  bbimg = extractor.Extract( plane, range[plane], range[fNPlanes], *digitVecHandle );
	
  // 	// compress image and bounding boxes
  // 	if ( _cropper_interaction.TargetWidth() < bbimg.width() || _cropper_interaction.TargetHeight() < bbimg.height() ) {
  // 	  bbimg.compress( _cropper_interaction.TargetHeight(), _cropper_interaction.TargetWidth(), larcaffe::Image::kMaxPool );
  // 	}
  // 	m_bb_nticks = bbimg.height();
  // 	m_bb_nwires = bbimg.width();

  // 	// transfer image to ROOT variables
  // 	m_bb_planeImages[plane]->resize( bbimg.height()*bbimg.width() );
  // 	for ( int w=0; w<(int)bbimg.width(); w++) {
  // 	  for (int t=0; t<(int)bbimg.height(); t++) {
  // 	    m_bb_planeImages[plane]->at( bbimg.height()*w + t ) = (int)bbimg.pixel( t, w );
  // 	  }
  // 	}

  //     }//end of planes loop to fill bounding boxes
      
  //     // save this bbox!
  //     m_bbox_label->push_back( m_interaction_list.at(ibox) );
  //     sprintf( m_bblabel, m_interaction_list.at(ibox).c_str() );
  //     m_BBTree->Fill();
  //     m_nfilledboxes++;
      
  //   }//end of loop over sets of bounding boxes for a given interaction
    
  //   // Finally fill the tree for this event
  //   m_ImageTree->Fill();

  // }// if RawDigits producer has been specified
    
  _time_prof_v[kANALYZE_TOTAL] += pWatchAnalyze.RealTime();
  _event_counter += 1;
}

void BNBCosmics::endJob() {

  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Writing output... " << std::endl;      

//   TStopwatch pWatchDB;
//   pWatchDB.Start();
//   for(auto& p_v : _db_v) {
//     for(auto& p : p_v) {

//       if(!p) continue;
      
//       p->write();
//       p->finalize();
      
//     }
//   }
//   double time = pWatchDB.RealTime();
//   _time_prof_v[kIO_DB] += time;
//   _time_prof_v[kANALYZE_TOTAL] += time;

  if(_logger.normal()){

    double diff=_time_prof_v[kANALYZE_TOTAL];
    for(size_t i=0; i<_time_prof_v.size(); ++i) {
      if(i == kANALYZE_TOTAL) continue;
      diff -= _time_prof_v[i];
    }

    _logger.LOG(::larcaffe::msg::kNORMAL,__FUNCTION__,__LINE__)
      << "Simple time profile record" << std::endl
      << "        [0] analyze time total ... " << _time_prof_v[kANALYZE_TOTAL] / _event_counter << " [sec/event] " << std::endl
      << "        [1] IO LArSoft ........... " << _time_prof_v[kIO_LARSOFT]    / _event_counter << " [sec/event] " << std::endl
      << "        [2] IO Cropper ........... " << _time_prof_v[kIO_CROPPER]    / _event_counter << " [sec/event] " << std::endl
      << "        [3] IO Storage ........... " << _time_prof_v[kIO_STORAGE]    / _event_counter << " [sec/event] " << std::endl
      << std::endl
      << "        [*] Unaccounted time ([0]-rest) ... " << diff / _event_counter << " [sec/event] " << std::endl
      << std::endl;

  } 
}

void BNBCosmics::setupTrees(int nplanes) {

  // define trees

  art::ServiceHandle<art::TFileService> ana_file;
  m_ImageTree = ana_file->make<TTree>( "imgtree", "Tree Containing Image and its MC Truth Info" );  // image of the entire event
  m_BBTree    = ana_file->make<TTree>( "bbtree", "Bounding Box Tree and its label" ); // images of each interaction within events
  
  // allocate image vectors for planes
  m_planeImages = new std::vector<int>*[fNPlanes];
  for (int p=0; p<fNPlanes; p++) {
    m_planeImages[p] = new std::vector<int>;
  }
  m_bb_planeImages = new std::vector<int>*[fNPlanes];
  for (int p=0; p<fNPlanes; p++) {
    m_bb_planeImages[p] = new std::vector<int>;
  }

  // ImageTree
  // ---------
    // add the plane images
  for (int i=0; i<nplanes; i++) {
    char branchname[20];
    sprintf( branchname, "img_plane%d", i );
    m_ImageTree->Branch( branchname, &(*m_planeImages[i]) );
    m_BBTree->Branch( branchname, &(*m_bb_planeImages[i]) );
  }
  m_ImageTree->Branch( "run", &m_run, "run/I" );
  m_ImageTree->Branch( "subrun", &m_subrun, "subrun/I" );
  m_ImageTree->Branch( "event", &m_event, "event/I" );
  m_ImageTree->Branch( "Enu", &m_Enu, "Enu/F" );
  m_ImageTree->Branch( "vertex", &m_vertex );
  m_ImageTree->Branch( "vertex_tw", &m_vertex_tw );
  m_ImageTree->Branch( "mode", &m_mode, "mode/I" );
  m_ImageTree->Branch( "nuscatter", &m_nuscatter, "nuscatter/I" );
  m_ImageTree->Branch( "interaction", &m_interaction, "interaction/I" );
  m_ImageTree->Branch( "flavor", &m_flavor, "flavor/I" );
  m_ImageTree->Branch( "nticks", &m_nticks, "nticks/I" );
  char chr_mwires[20];
  sprintf( chr_mwires, "wires[%d]/I",fNPlanes );
  m_wires = new int[fNPlanes];
  m_ImageTree->Branch( "nwires", m_wires, chr_mwires );
  m_ImageTree->Branch( "label", m_label, "label[50]/C" );

  // Bounding Box Tree
  m_BBTree->Branch( "run", &m_run, "run/I" );
  m_BBTree->Branch( "subrun", &m_subrun, "subrun/I" );
  m_BBTree->Branch( "event", &m_event, "event/I" );
  m_BBTree->Branch( "nboxes", &m_nfilledboxes, "nboxes/I" );
  m_BBTree->Branch( "label", m_bblabel, "label[100]/C" );
  m_BBTree->Branch( "Enu", &m_Enu, "Enu/F" );
  m_BBTree->Branch( "vertex", &m_vertex );
  m_BBTree->Branch( "vertex_tw", &m_vertex_tw );

  // Bounding Box Branches: one for each plane
  // ugh, these branches are such bad code...
  m_plane_bb_loleft_t = new std::vector<int>*[nplanes];
  m_plane_bb_loleft_w = new std::vector<int>*[nplanes];
  m_plane_bb_loright_t = new std::vector<int>*[nplanes];
  m_plane_bb_loright_w = new std::vector<int>*[nplanes];
  m_plane_bb_hiright_t = new std::vector<int>*[nplanes];
  m_plane_bb_hiright_w = new std::vector<int>*[nplanes];
  m_plane_bb_hileft_t = new std::vector<int>*[nplanes];
  m_plane_bb_hileft_w = new std::vector<int>*[nplanes];
  m_plane_bbinteraction_loleft_t = new int[nplanes];
  m_plane_bbinteraction_loleft_w = new int[nplanes];
  m_plane_bbinteraction_hiright_t = new int[nplanes];
  m_plane_bbinteraction_hiright_w = new int[nplanes];
  for (int plane=0; plane<nplanes; plane++) {
    m_plane_bb_loleft_t[plane] = new std::vector<int>;
    m_plane_bb_loleft_w[plane] = new std::vector<int>;
    m_plane_bb_hileft_t[plane] = new std::vector<int>;
    m_plane_bb_hileft_w[plane] = new std::vector<int>;
    m_plane_bb_loright_t[plane] = new std::vector<int>;
    m_plane_bb_loright_w[plane] = new std::vector<int>;
    m_plane_bb_hiright_t[plane] = new std::vector<int>;
    m_plane_bb_hiright_w[plane] = new std::vector<int>;

    // set the ttree branch
    char branchname[100];

    sprintf( branchname, "LoLeft_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loleft_t[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_loleft_t[plane] );
    sprintf( branchname, "LoLeft_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loleft_w[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_loleft_w[plane] );

    sprintf( branchname, "LoRight_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loright_t[plane]) );
    sprintf( branchname, "LoRight_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loright_w[plane]) );

    sprintf( branchname, "HiRight_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hiright_t[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_hiright_t[plane] );
    sprintf( branchname, "HiRight_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hiright_w[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_hiright_w[plane] );

    sprintf( branchname, "HiLeft_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hileft_t[plane]) );
    sprintf( branchname, "HiLeft_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hileft_w[plane]) );
  }
  
  m_bbox_label = new std::vector<std::string>;
  m_ImageTree->Branch( "bblabels", m_bbox_label );
}

void BNBCosmics::clearBoundingBoxes() {
  
  m_bbox_label->clear();
  for (int plane=0; plane<fNPlanes; plane++) {
    m_plane_bb_loleft_t[plane]->clear();
    m_plane_bb_loleft_w[plane]->clear();
    m_plane_bb_loright_t[plane]->clear();
    m_plane_bb_loright_w[plane]->clear();
    m_plane_bb_hiright_t[plane]->clear();
    m_plane_bb_hiright_w[plane]->clear();
    m_plane_bb_hileft_t[plane]->clear();
    m_plane_bb_hileft_w[plane]->clear();
  }
  
}

DEFINE_ART_MODULE(BNBCosmics)
