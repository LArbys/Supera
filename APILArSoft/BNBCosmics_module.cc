////////////////////////////////////////////////////////////////////////
// Class:       BNBCosmics
// Module Type: analyzer
// File:        BNBCosmics_module.cc
//
// Generated at Wed Dec 30 15:55:44 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

/*
  The YOLO module behaves slightly differently than the Supera module,
    at least enough to warrant an experimental module.
    
  YOLO does a fix crop of an image and downsamples it to 448x448 (the input for the darknet yolo network)
  It does a fix crop (specified in FCL file) of the entire event and finds the bounding boxes for interactions.
  It scales the above down to a 448x448 image.
  Along with the image, bounding boxes around the different interactions are found.
  All of this is saved in a ROOT file, which stores MCTruth info, the bounding box info, and the image itself.
  Scripts can be used to augment and manipulate this data.
  A script will also be used to output the data in the format YOLO wants, which is a folder of images, a text file
    with the names of the images, and a folder of text files with the label and bounding box information.
 */

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Optional/TFileService.h"

#include <limits>
#include <climits>
#include <set>

#include <TStopwatch.h>

#include "Geometry/Geometry.h" //LArCore
#include "Utilities/DetectorProperties.h" // LArData
#include "Utilities/LArProperties.h"
#include "RawData/RawDigit.h" // LArData
#include "Simulation/SimChannel.h" // LArSim
#include "SimulationBase/GTruth.h" // NuTools
#include "SimulationBase/MCTruth.h" // NuTools
#include "SimulationBase/MCNeutrino.h" // NuTools
#include "MCBase/MCTrack.h" // LArData
#include "MCBase/MCShower.h" // LArData
#include "RawData/OpDetWaveform.h" // LArData
#include "Utilities/TimeService.h" // LArCore?

#include "ConverterAPI.h"
#include "SuperaCore/lmdb_converter.h"
#include "Cropper.h"
#include "LArCaffe/larbys.h"
#include "LArCaffe/LArCaffeUtils.h"
#include "FilterBase.h"
#include "ImageExtractor.h"
#include "MCParticleTree.h"

#include "TTree.h" // ROOT

const size_t LMDB_MAP_SIZE = 1099511627776;  // 1 TB

class BNBCosmics;

class BNBCosmics : public art::EDAnalyzer {
public:
  explicit BNBCosmics(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  BNBCosmics(BNBCosmics const &) = delete;
  BNBCosmics(BNBCosmics &&) = delete;
  BNBCosmics & operator = (BNBCosmics const &) = delete;
  BNBCosmics & operator = (BNBCosmics &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  void beginJob();
  void endJob();
  void finalize();
  
public:

  enum TimeProfCategory_t {
    kIO_LARSOFT,
    kIO_MCTRACK,
    kIO_CROPPER,
    kIO_STORAGE,
    kANALYZE_TOTAL,
    kTIMEPROFCATEGORYMAX
  };

private:

  void LoadDataHandles( const art::Event& e, 
			art::Handle< std::vector<raw::RawDigit> >& digitVecHandle,
			art::Handle< std::vector<recob::Wire> >& wireVecHandle );
  std::vector<larcaffe::RangeArray_t> setEventCrop(const art::Event& e);
  void ExtractImage( const art::Event& e, const std::vector<larcaffe::RangeArray_t>& region_v, std::vector<int>& applied_plane_compression_factors );
  std::vector<larcaffe::RangeArray_t> findBoundingBoxes( larbys::supera::MCParticleTree& particletree, std::vector<int>& interaction_indices );
  void processBoundingBoxes( const art::Event& e, 
			     const std::vector<larcaffe::RangeArray_t>& bboxes, 
			     const larcaffe::RangeArray_t& the_range_v, 
			     const std::vector<int>& plane_compression,
			     const std::vector<int>& interaction_indices,
			     const larbys::supera::MCParticleTree& particletree );
  std::string labelBoundingBox( int key, const std::vector<larbys::supera::MCPTInfo>& bundle );
  void getMCTruth( art::Event const & e );
  void PreparePMTImage( const art::Event& e );
  void clearBoundingBoxes();

  // ----------------------------------------------------------------------
  // fichl parameters
  bool fCropInteractions; //< crop interactions into their own image
  std::vector<bool> _plane_enable_v; //< which planes to extract images for
  std::string fImageSource; //< [RawDigits, Wire, Hit]
  fhicl::ParameterSet fProducers; // name of producers
  bool fSkipNeutrons;
  std::string fOpDataModule;

  ::larcaffe::RangeArray_t _wiretime_range_hard_v; //< ranges for (planes,...,time ticks)

  ::larcaffe::supera::Cropper _cropper; //< cropper for the entire event
  ::larcaffe::supera::Cropper _cropper_interaction; //< cropper for the interactions
  ::larcaffe::logger _logger; //< output logger

  std::vector<std::string> _producer_v; //< name of producers
  std::vector<double> _time_prof_v; //< stores times of different steps
  double _event_counter; 
  std::vector< larcaffe::supera::FilterBase* > _filter_list; //< list of image filters (not really used)

  // ----------------------------------------------------------------------
  // ROOT tree members
  void setupTrees();

  TTree* m_ImageTree; //< whole image crop
  TTree* m_BBTree;    //< interaction image crop
  std::vector<int>** m_planeImages; //< [planeid][row-major 2D image]
  std::vector<int>* m_pmtImageHighGain; // [row-major 2D image]
  std::vector<int>* m_pmtImageLowGain; // [row-major 2D image]
  int m_event; //< event ID (ImageTree,BBTree)
  int m_subrun; //< subrun ID (ImageTree,BBTree)
  int m_run; //< run ID (ImageTree,BBTree)
  int m_nfilledboxes; // (ImageTree)
  float m_Enu; //< neutrino energy (energy of primary for cosmics or single particles) (ImageTree)
  int m_mode; //< interaction mode (-1 if cosmic)
  int m_nuscatter; // neutrino scattering code
  int m_flavor; //< neutrino flavor (-1 if cosmic)
  int m_interaction; //< neutrino interaction type (-1 cosmics)
  int m_nticks; //< image height in time ticks
  int* m_wires;  //< image width in wires [planeid]
  int fNPlanes; //< number of wire planes
  bool fUseWire;
  bool fGroupAllInteractions;
  bool fUseSimChannel;
  bool fSingleParticleMode;
  bool fHasNeutrino;
  bool fIsMC;
  std::string singlepname;

  // bounding boxes: stuck doing this because want to make flat branch tree
  
  // for events
  std::vector<int>** m_plane_bb_loleft_t; // (ImageTree)
  std::vector<int>** m_plane_bb_loleft_w; // (ImageTree)
  std::vector<int>** m_plane_bb_hileft_t; // (ImageTree)
  std::vector<int>** m_plane_bb_hileft_w; // (ImageTree)
  std::vector<int>** m_plane_bb_loright_t; // (ImageTree)
  std::vector<int>** m_plane_bb_loright_w; // (ImageTree)
  std::vector<int>** m_plane_bb_hiright_t; // (ImageTree)
  std::vector<int>** m_plane_bb_hiright_w; // (ImageTree)
  std::vector<std::string>* m_bbox_label;  // (ImageTree)
  std::vector< float >* m_bb_3D_vertex_x;   //< the true vertex in 3D space of bounding box (ImageTree)
  std::vector< float >* m_bb_3D_vertex_y;   //< the true vertex in 3D space of bounding box (ImageTree)
  std::vector< float >* m_bb_3D_vertex_z;   //< the true vertex in 3D space of bounding box (ImageTree)
  std::vector< float >* m_bb_3D_vertex_t;   //< the true vertex in 3D space of bounding box (ImageTree)
  std::vector<int>**   m_plane_bb_vertexpixel_wire; // (ImageTree)
  std::vector<int>*    m_plane_bb_vertexpixel_time; // (ImageTree)


  char m_label[50];

  // for individual bounding boxes tree
  std::vector<int>** m_bb_planeImages; // [planeid][row-major 2D Image, unrolled] (BBtree)
  int* m_plane_bbinteraction_loleft_t; 
  int* m_plane_bbinteraction_loleft_w;
  int* m_plane_bbinteraction_hiright_t;
  int* m_plane_bbinteraction_hiright_w;
  char m_bblabel[100];
  int m_bb_nticks;
  int m_bb_nwires;
  
  std::vector< std::string > m_interaction_list; ///< labels for bounding boxes


};

BNBCosmics::BNBCosmics(fhicl::ParameterSet const & p)
  : EDAnalyzer(p)
  , _logger("BNBCosmics")
  , _time_prof_v(kTIMEPROFCATEGORYMAX,0.)
  , _event_counter(0)
{
  // ------------------------------------------------
  // DETERMINE CONSTANTS

  // set number of planes
  art::ServiceHandle<geo::Geometry> geom;
  fNPlanes = geom->Nplanes();

  // ------------------------------------------------
  // FICHL PARAMETERS
  
  // set verbosity
  ::larcaffe::msg::Level_t vlevel = (larcaffe::msg::Level_t)(p.get<unsigned short>("Verbosity",1));
  _logger.set(vlevel);
  _cropper.set_verbosity(vlevel);

  // set active planes
  _plane_enable_v = p.get<std::vector<bool> >("EnablePlane");
  if(_plane_enable_v.size() != geom->Nplanes()) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "EnablePlane parameter must be length " << geom->Nplanes() << " (# of planes) boolean array!" << std::endl;
    throw ::larcaffe::larbys();
  }

  // crop interactions
  fCropInteractions = p.get<bool>( "CropInteractions", false );
  
  // store producers
  fProducers = p.get<fhicl::ParameterSet>("Producers");
  _producer_v.resize(3,"");
  _producer_v[0] = fProducers.get<std::string>("RawDigit");
  _producer_v[1] = fProducers.get<std::string>("Wire");
  _producer_v[2] = fProducers.get<std::string>("Hit");
  if(_producer_v.size()!=3) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Producers parameter must be length 3 string array (producer names for raw digit, wire, and hit respectively)!" << std::endl
      << "Leave empty string to skip using specific product. An array of 3 empty strings will also cause this message!" << std::endl;
    throw ::larcaffe::larbys();
  }
  _logger.LOG(::larcaffe::msg::kNORMAL,__FUNCTION__,__LINE__)
    << "Using data producers: (RawDigit, Wire, Hit) = (" 
    << _producer_v[0] <<", " <<  _producer_v[1] << ", " << _producer_v[2] << ")" << std::endl;

  // Image Source
  fImageSource = p.get<std::string>("ImageSource");
  if ( fImageSource!="RawDigit" && fImageSource!="Wire" && fImageSource!="Hit" ) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected Image source, " << fImageSource << ". choices: RawDigit, Wire, Hit." << std::endl;
    throw ::larcaffe::larbys();    
  }

  // Producer for waveforms
  fOpDataModule = p.get<std::string>("OpDataModule");
  
  // cropper parameters
  fhicl::ParameterSet cropper_params = p.get<fhicl::ParameterSet>("EventCropperConfig");
  fhicl::ParameterSet interaction_cropper_params = p.get<fhicl::ParameterSet>("InteractionCropperConfig");

  // crop interactions
  fSkipNeutrons = p.get<bool>( "SkipNeutrons", false );

  // tell module to look for neutrino MC truth info
  fHasNeutrino = p.get<bool>("HasNeutrino",false);

  // is the file MC?
  fIsMC = p.get<bool>("IsMC");

  // ------------------------------------------------------
  // Configure Croppers

  // event cropper parameters
  std::vector<unsigned int> cropper_config;
  cropper_config.push_back( cropper_params.get< unsigned int >( "TimePadding" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "WirePadding" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "TimeTargetSize" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "WireTargetSize" ) );
  cropper_config.push_back( cropper_params.get< unsigned int >( "CompressionFactor" ) );
  if(cropper_config.size()==5){
    // we got them all. setup the cropper.
    _cropper.configure(cropper_config[0],
		       cropper_config[1],
		       cropper_config[2],
		       cropper_config[3],
		       cropper_config[4]);
  }else{
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected length of event cropper configuration (length=" << cropper_config.size() 
      << ") ... must be length 5 unsigned int array" << std::endl;
    throw ::larcaffe::larbys();
  }

  // interaction cropper config
  cropper_config.clear();
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "TimePadding" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "WirePadding" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "TimeTargetSize" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "WireTargetSize" ) );
  cropper_config.push_back( interaction_cropper_params.get< unsigned int >( "CompressionFactor" ) );
  if(cropper_config.size()==5){
    // we got them all. setup the cropper.
    _cropper_interaction.configure(cropper_config[0],
				   cropper_config[1],
				   cropper_config[2],
				   cropper_config[3],
				   cropper_config[4]);
  }else{
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Unexpected length of interaction cropper configuration (length=" << cropper_config.size() 
      << ") ... must be length 5 unsigned int array" << std::endl;
    throw ::larcaffe::larbys();
  }

  // set cropper hard limit (dependent on cropper params)
  std::vector<std::pair<int,int> > range_v = p.get<std::vector<std::pair<int,int> > >("HardLimitRange");
  if(range_v.size() != (geom->Nplanes() + 1)) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "HardLimitRange must be length " << geom->Nplanes() + 1 << " (wire plane count + 1 for time)!" << std::endl;
    throw ::larcaffe::larbys();
  }
  _wiretime_range_hard_v.resize( range_v.size() );
  for(size_t plane=0; plane<range_v.size(); ++plane) {
    if ( range_v.at(plane).first<0 ) {
      // unspecified
      if ( (int)plane<fNPlanes ) {
	// unspecified wires: we take all of them (that will fit in multiple of target size)
	_wiretime_range_hard_v.at(plane).start = 0;
	int nfactors = (geom->Nwires(plane))/_cropper.TargetWidth();
	if ( geom->Nwires(plane)%_cropper.TargetWidth()!=0 )
	  nfactors+=1;
	_wiretime_range_hard_v.at(plane).end = nfactors*_cropper.TargetWidth() - 1;
	// maybe i should center this
      }
      else {
	_logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Time ticks need hard range" << std::endl;
	throw ::larcaffe::larbys();
      }
    }
    else {
      // specified range
      _wiretime_range_hard_v.at(plane).start  = (unsigned int)range_v.at(plane).first;
      _wiretime_range_hard_v.at(plane).end = (unsigned int)range_v.at(plane).second;
    }
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
      << "setting hard limit for plane=" << plane 
      << ": " << _wiretime_range_hard_v.at(plane).start << " " << _wiretime_range_hard_v.at(plane).end << std::endl;
    _wiretime_range_hard_v.at(plane).setFilled();
  }
  larcaffe::PrintRangeArray( _wiretime_range_hard_v );
  
  // setup filters: can remove images
  std::vector<std::string> filter_names = p.get< std::vector<std::string> >( "ImageFilters" );
  fhicl::ParameterSet filter_params = p.get< fhicl::ParameterSet >( "FilterConfigs" );
  for ( std::vector<std::string>::iterator it_string=filter_names.begin(); it_string!=filter_names.end(); it_string++ ) {
    std::string filter_name = *it_string;
    ::larcaffe::supera::FilterBase* filter = ::larcaffe::supera::FilterFactory::get()->create( filter_name );
    fhicl::ParameterSet params = filter_params.get< fhicl::ParameterSet >( filter_name );
    filter->configure( params );
    _filter_list.emplace_back( filter );
  }
  
  // setup output Trees
  setupTrees();
  
  
}
			   
void BNBCosmics::beginJob() {
}

std::vector<larcaffe::RangeArray_t> BNBCosmics::setEventCrop(const art::Event& e) 
{
  // sets the fixed range as the crop range
  art::ServiceHandle<geo::Geometry> geom;

  std::vector<larcaffe::RangeArray_t> image_v;

  // the fixed crop
  image_v.push_back( _wiretime_range_hard_v );
  
  return image_v;
}

std::vector<larcaffe::RangeArray_t> BNBCosmics::findBoundingBoxes( larbys::supera::MCParticleTree& particletree, std::vector<int>& interaction_indices ) 
{
  // we group tracks belong to same interaction and make a bounding box for it
  // we need to group cosmic rays and neutrino interactions
  // the hardest part of this code
  // returns bounding box. a vector of the interaction indices (MCParticleTree.m_bundle) is also returned in case one wants
  //  to do stuff with the interactions. (and we do, we will determine the vertices for each)

  art::ServiceHandle<geo::Geometry> geom;

  std::vector<larcaffe::RangeArray_t> image_v;

  // neutrino interactions from MCTruth
  // art::Handle< std::vector<simb::MCTruth> > gentruth;
  // e.getByLabel( "generator", gentruth );
  // // below is not needed
  // const std::vector<simb::MCTruth>& genie = *gentruth;
  // fWatch.Start();
  // for (int ineutrino=0; ineutrino<(int)genie.size(); ineutrino++) {
  //   particletree.addNeutrinoInteraction( genie.at(ineutrino) );
  // }
  // _time_prof_v[kIO_MCTRACK] += fWatch.RealTime();
 
  m_interaction_list.clear();
  interaction_indices.clear();  
  //for ( std::map< int, std::vector<larbys::supera::MCPTInfo> >::iterator it_bundle=particletree.m_bundles.begin(); it_bundle!=particletree.m_bundles.end(); it_bundle++ ) {
  for ( auto const& it_bundle : particletree.m_bundles) {
    // now find bounding box of each interaction
    double deposit_energy = 0;
    for(auto const& mcpt : it_bundle.second) deposit_energy += mcpt.calcDepositEnergy();
    if(deposit_energy < 50) continue;

    auto range_array = _cropper_interaction.Format( _cropper_interaction.WireTimeBoundary( it_bundle.second ) );
    
    if ( it_bundle.first<0 )
      std::cout << "[neutrino] ";
    else
      std::cout << "[cosmic] ";
    std::cout << " energy " << deposit_energy << " ";
    if ( !larcaffe::RangesOK( range_array ) ) {
      std::cout << "Range of bundle is empty or invalid." << std::endl;
      continue;
    }
    else {
      std::cout << "Valid Interaction Bundle: ";
      larcaffe::PrintRangeArray( range_array );
    }

    image_v.push_back( range_array ); // we put it into the collection
    interaction_indices.push_back( it_bundle.first );
    // simple for now, but future we want cosmic_muon, cosmic_muon_wdecaye, cosmic_muon_wpizero, cosmic_emshower, cosmic_hadronic, cosmic_hadronic_wpizero
    std::string thebblabel = labelBoundingBox( it_bundle.first, it_bundle.second );
    m_interaction_list.push_back( thebblabel );
    // if ( (*it_bundle).first<0 )
    //   m_interaction_list.push_back( "neutrino" );
    // else
    //   m_interaction_list.push_back( "cosmic" );
  }
  
  return image_v;
  
}//end of findboundingboxes

void BNBCosmics::processBoundingBoxes( const art::Event& e,
				       const std::vector<larcaffe::RangeArray_t>& bboxes, 
				       const larcaffe::RangeArray_t& the_range_v,
				       const std::vector<int>& plane_compression,
				       const std::vector<int>& interaction_indices,
				       const larbys::supera::MCParticleTree& particletree ) {
  // here we put them into the tree. we save the images if unstructed to do so
  // we list the position of the bounding boxes within the coordiante system of an event image (the_range_v)

  if ( (int)plane_compression.size()!=(fNPlanes+1) ) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Compression factors for each plane is missing or incomplete." << std::endl;
    throw ::larcaffe::larbys();
  }
  if ( bboxes.size()!=interaction_indices.size() ) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__)
      << "Number of bounding boxes does not match the number of interaction indices." << std::endl;
    throw ::larcaffe::larbys();
  }

  // clear tree variables
  clearBoundingBoxes();
  
  // get the data/services
  art::ServiceHandle<util::TimeService> ts;
  art::ServiceHandle<geo::Geometry> geom;
  art::ServiceHandle<util::LArProperties> larp;
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  art::Handle< std::vector<recob::Wire> > wireVecHandle;
  LoadDataHandles( e, digitVecHandle, wireVecHandle );

  // the image extractor
  larcaffe::supera::ImageExtractor extractor;

  int ibox = -1;
  m_nfilledboxes = 0;
  for ( auto &bbox : bboxes ) {
    // bbox is an RangeArray_t object
    ibox++;
    
    // stay within the event range's time window
    if ( bbox[fNPlanes].end<the_range_v[fNPlanes].start 
	 || bbox[fNPlanes].start>the_range_v[fNPlanes].end )
      continue;

    // calculate time bounds in event image coordinates
    int t_lo = (int)bbox[fNPlanes].start  - (int)the_range_v[fNPlanes].start;
    int t_hi = (int)bbox[fNPlanes].end - (int)the_range_v[fNPlanes].start;

    // enforce time bounds
    t_lo = std::max( t_lo, 0 );
    t_hi = std::min( t_hi, (int)the_range_v[fNPlanes].end-(int)the_range_v[fNPlanes].start );

    for (int plane=0; plane<fNPlanes; plane++) {
      
      // need to correct bounding box coodindates for event images compression factor
      // bounding box goes counter clockwise from origin
	
      int w_lo = (int)bbox[plane].start  - (int)the_range_v[plane].start;
      int w_hi = (int)bbox[plane].end - (int)the_range_v[plane].start;
	
      // enforce wire range bounds
      w_lo = std::max( w_lo, 0 );
      w_hi = std::min( w_hi, (int)the_range_v[plane].end-(int)the_range_v[plane].start);

      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) 
	<< "[Plane " << plane << " BBOX]"
	<< " t=[" << (int)the_range_v[fNPlanes].start+t_lo << ", " << (int)the_range_v[fNPlanes].start+t_hi << "]"
	<< " w=[" << (int)the_range_v[plane].start+w_lo << ", " << (int)the_range_v[plane].start+w_hi << "]"
	<< " image bound: t=[" << the_range_v[fNPlanes].start << ", " << the_range_v[fNPlanes].end <<"]"
	<< " w=[" << the_range_v[plane].start << ", " << the_range_v[plane].end << "]" << std::endl;

      m_plane_bb_loleft_t[plane]->push_back( t_lo/plane_compression[fNPlanes] );
      m_plane_bb_loleft_w[plane]->push_back( w_lo/plane_compression[plane] );
      
      m_plane_bb_loright_t[plane]->push_back( t_lo/plane_compression[fNPlanes] );
      m_plane_bb_loright_w[plane]->push_back( w_hi/plane_compression[plane] );
      
      m_plane_bb_hiright_t[plane]->push_back( t_hi/plane_compression[fNPlanes] );
      m_plane_bb_hiright_w[plane]->push_back( w_hi/plane_compression[plane] );
      
      m_plane_bb_hileft_t[plane]->push_back( t_hi/plane_compression[fNPlanes] );
      m_plane_bb_hileft_w[plane]->push_back( w_lo/plane_compression[plane] );
      
      // save image for bbox, if we are told to do so
      if ( fCropInteractions ) {
	larcaffe::Image bbimg;
	if ( fImageSource=="Wire" )
	  bbimg = extractor.Extract( plane, bbox[plane], bbox[fNPlanes], *wireVecHandle );
	else if ( fImageSource=="RawDigits" )
	  bbimg = extractor.Extract( plane, bbox[plane], bbox[fNPlanes], *digitVecHandle );
	else
	  throw ::larcaffe::larbys();
	
	// compress image and bounding boxes
	if ( _cropper_interaction.TargetWidth() < bbimg.width() || _cropper_interaction.TargetHeight() < bbimg.height() ) {
	  bbimg.compress( _cropper_interaction.TargetHeight(), _cropper_interaction.TargetWidth(), larcaffe::Image::kMaxPool );
	}
	m_bb_nticks = bbimg.height();
	m_bb_nwires = bbimg.width();
	
	// transfer image to ROOT variables
	m_bb_planeImages[plane]->resize( bbimg.height()*bbimg.width() );
	for ( int w=0; w<(int)bbimg.width(); w++) {
	  for (int t=0; t<(int)bbimg.height(); t++) {
	    m_bb_planeImages[plane]->at( bbimg.height()*w + t ) = (int)bbimg.pixel( t, w );
	  }
	}
      }//end of if crop
      
    }//end of planes loop to fill bounding boxes
    
    // save this bbox!
    m_bbox_label->push_back( m_interaction_list.at(ibox) );

    // vertex
    float bbvertex[4];
    auto iter = particletree.m_bundles.find(interaction_indices.at(ibox));
    if ( iter==particletree.m_bundles.end() ) {
      std::cout << "WTF!" << std::endl;
      throw ::larcaffe::larbys();
    }
    particletree.determineVertex( bbvertex, (*iter).second ) ;
    std::cout << "returned vertex." << std::endl;
    m_bb_3D_vertex_x->push_back( bbvertex[0] );
    m_bb_3D_vertex_y->push_back( bbvertex[1] );
    m_bb_3D_vertex_z->push_back( bbvertex[2] );
    m_bb_3D_vertex_t->push_back( ts->TPCG4Time2Tick(bbvertex[3]) );

    // now we need to convert to pixel coordinates
    // the time coordinate
    const double drift_velocity = larp->DriftVelocity()*1.0e-3;
    const double wireplane_offset = 7.0; //cm
    int bb_tick = (int)(ts->TPCG4Time2Tick( bbvertex[3] + (bbvertex[0]+wireplane_offset)/drift_velocity ))+1 - (int)the_range_v[fNPlanes].start;
    bb_tick /= plane_compression.at(fNPlanes);
    m_plane_bb_vertexpixel_time->push_back( bb_tick );

    double xyz[3] = { (double)bbvertex[0], (double)bbvertex[1], (double)bbvertex[2] };

    for (int iplane=0; iplane<fNPlanes; iplane++) {
      geo::WireID wire_id;
      try {
	wire_id = geom->NearestWireID(xyz, iplane);
      }
      catch (geo::InvalidWireIDError& err) {
	//std::cout << "out of bounds. using better number" << std::endl;
	// if ( std::fabs(xyz[2]-1000.0) < std::fabs(xyz[2]) )
	// 	wire_id.Wire = geom->Nwires(plane);
	// else
	    // 	wire_id.Wire = 0;
	wire_id.Wire = err.better_wire_number;
      }
      catch (...) {
	//std::cout << "out of bounds. using better number" << std::endl;
	if ( std::fabs(xyz[2]-1000.0) < std::fabs(xyz[2]) )
	  wire_id.Wire = geom->Nwires(iplane);
	else
	  wire_id.Wire = 0;
      }
      int bbwire = (int)wire_id.Wire - (int)the_range_v[iplane].start;
      bbwire /= plane_compression.at(iplane);
      m_plane_bb_vertexpixel_wire[iplane]->push_back( bbwire );
    }

    //sprintf( m_bblabel, m_interaction_list.at(ibox).c_str() );
    m_BBTree->Fill();
    m_nfilledboxes++;
  }// end of bounding box loop
  
}//end of processBoundingBox

void BNBCosmics::getMCTruth( art::Event const & e ) {
  // Sets the MC truth variables to be stored in m_ImageTree
  
  // GENIE data to get interaction mode and neutrino energy if possible
  art::Handle< std::vector<simb::MCTruth> > gentruth;
  e.getByLabel( "generator", gentruth );
  if ( !fHasNeutrino ) {
    _logger.LOG(::larcaffe::msg::kINFO, __FUNCTION__,__LINE__) << "No GENIE Truth. Must be Cosmic Event" << std::endl;
    m_flavor = -1;
    m_mode = -1;
    m_interaction = -1;
    m_nuscatter = -1;
    m_Enu = 0.0;
    const std::vector<simb::MCTruth>& genie = *gentruth;
    m_Enu = genie.at(0).GetParticle(0).E();
    // m_vertex.resize(4, 0.0 );
    // m_vertex.at(0) = genie.at(0).GetParticle(0).Vx();
    // m_vertex.at(1) = genie.at(0).GetParticle(0).Vy();
    // m_vertex.at(2) = genie.at(0).GetParticle(0).Vz();
    // m_vertex.at(3) = genie.at(0).GetParticle(0).T();

  }
  else {
  
    const std::vector<simb::MCTruth>& genie = *gentruth;
    if ( genie.size()!=1 ) {
      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Unexpected number of MCTruth objects = " << genie.size() << std::endl;
      if ( genie.size()==0)
	throw ::larcaffe::larbys();
    }
    m_mode = genie.at(0).GetNeutrino().Mode();
    m_nuscatter = genie.at(0).GetNeutrino().CCNC();
    m_interaction = genie.at(0).GetNeutrino().InteractionType();
    m_flavor = genie.at(0).GetNeutrino().Nu().PdgCode();
    
    // Get neutrino energy
    m_Enu = genie.at(0).GetNeutrino().Nu().E();

    // Get Vertex
    // m_vertex.resize(4, 0.0);
    // m_vertex.at(0) = genie.at(0).GetParticle(0).Vx();
    // m_vertex.at(1) = genie.at(0).GetParticle(0).Vy();
    // m_vertex.at(2) = genie.at(0).GetParticle(0).Vz();
    // m_vertex.at(3) = genie.at(0).GetParticle(0).T();

  }

  // Get Vertex in terms of time and wire
  //art::ServiceHandle<geo::Geometry> geom;
    
  //const int tick_max = detp->NumberTimeSamples();
  
  // vertex stuff
  // m_vertex_tw.resize(geom->Nplanes()+1,0);
  // for (size_t iplane=0; iplane<geom->Nplanes(); iplane++) {
  //   geo::WireID wire_id;
  //   try {
  //     wire_id = geom->NearestWireID(m_vertex.data(), iplane);
  //   }
  //   catch (geo::InvalidWireIDError& err) {
  //     //std::cout << "out of bounds. using better number" << std::endl;
  //     wire_id.Wire = err.better_wire_number;
  //   }
  //   m_vertex_tw.at(iplane) = wire_id.Wire;
  // }  
  // int tick = (int)(ts->TPCG4Time2Tick(m_vertex.at(3) + (m_vertex.at(0) / drift_velocity))) + 1;
  // m_vertex_tw.at(3) = tick;
  
}
  


void BNBCosmics::analyze(art::Event const & e)
{
  TStopwatch pWatchAnalyze,pWatchDB,pWatchDatum,pWatchLArIO;
  pWatchAnalyze.Start();
  
  // Implementation of required member function here.
  if(_logger.debug())
    _logger.LOG(::larcaffe::msg::kDEBUG,__FUNCTION__,__LINE__) << "Load RawDigits Handle" << std::endl;

  // Event Code
  m_event  = (int)e.event();
  m_run    = (int)e.run();
  m_subrun = (int)e.subRun();

  //
  // Save event image
  //

  // Determine the event image region size
  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Extracting image array" << std::endl;
  auto region_v = setEventCrop(e);
  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Extracted " << region_v.size() << " images!" << std::endl;

  // Extract it and save to ROOT file
  std::vector<int> applied_plane_compression_factors;
  ExtractImage( e, region_v, applied_plane_compression_factors );

  // save pmt image
  PreparePMTImage( e );
  

  // Get MC Truth
  if ( fIsMC ) {

    getMCTruth( e );
    
    
    //
    // Determine bounding boxes
    //
    
    // first bundle the truth info
    TStopwatch fWatch; fWatch.Start();
    art::Handle<std::vector<sim::MCTrack> > mctHandle;
    e.getByLabel("mcreco",mctHandle);
    if(!mctHandle.isValid()) {
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Missing MCTrack info (cannot make image-per-interaction)!" << std::endl;
      throw ::larcaffe::larbys();
    }
    art::Handle<std::vector<sim::MCShower>> mcshHandle;
    e.getByLabel("mcreco",mcshHandle);
    if(!mcshHandle.isValid()) {
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Missing MCShower info (cannot make image-per-interaction)!" << std::endl;
      throw ::larcaffe::larbys();
    }
    _time_prof_v[kIO_LARSOFT] += fWatch.RealTime();
    
    // create sets of interactions
    larbys::supera::MCParticleTree particletree( *mctHandle, *mcshHandle );
    // Parse Shower and Track info and bundle them by ancestor
    fWatch.Start();
    particletree.parse();
    particletree.boom();
    _time_prof_v[kIO_MCTRACK] += fWatch.RealTime();
  
    // get list of boxes for each interaction set
    std::vector<int> interaction_indices;
    auto bboxes = findBoundingBoxes( particletree, interaction_indices);
    // save them to ROOTFiles
    processBoundingBoxes( e, bboxes, region_v[0], applied_plane_compression_factors, interaction_indices, particletree );
  }
    
  // save everything
  m_ImageTree->Fill();

  _event_counter += 1;
}

void BNBCosmics::endJob() {

  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Writing output... " << std::endl;      

//   TStopwatch pWatchDB;
//   pWatchDB.Start();
//   for(auto& p_v : _db_v) {
//     for(auto& p : p_v) {

//       if(!p) continue;
      
//       p->write();
//       p->finalize();
      
//     }
//   }
//   double time = pWatchDB.RealTime();
//   _time_prof_v[kIO_DB] += time;
//   _time_prof_v[kANALYZE_TOTAL] += time;

  if(_logger.normal()){

    double diff=_time_prof_v[kANALYZE_TOTAL];
    for(size_t i=0; i<_time_prof_v.size(); ++i) {
      if(i == kANALYZE_TOTAL) continue;
      diff -= _time_prof_v[i];
    }

    _logger.LOG(::larcaffe::msg::kNORMAL,__FUNCTION__,__LINE__)
      << "Simple time profile record" << std::endl
      << "        [0] analyze time total ... " << _time_prof_v[kANALYZE_TOTAL] / _event_counter << " [sec/event] " << std::endl
      << "        [1] IO LArSoft ........... " << _time_prof_v[kIO_LARSOFT]    / _event_counter << " [sec/event] " << std::endl
      << "        [2] MC Track grouping .... " << _time_prof_v[kIO_MCTRACK]    / _event_counter << " [sec/event] " << std::endl
      << "        [3] IO Cropper ........... " << _time_prof_v[kIO_CROPPER]    / _event_counter << " [sec/event] " << std::endl
      << "        [4] IO Storage ........... " << _time_prof_v[kIO_STORAGE]    / _event_counter << " [sec/event] " << std::endl
      << std::endl
      << "        [*] Unaccounted time ([0]-rest) ... " << diff / _event_counter << " [sec/event] " << std::endl
      << std::endl;

  } 
}

void BNBCosmics::setupTrees() {

  // define trees

  art::ServiceHandle<art::TFileService> ana_file;
  m_ImageTree = ana_file->make<TTree>( "imgtree", "Tree Containing Image and its MC Truth Info" );  // image of the entire event
  m_BBTree    = ana_file->make<TTree>( "bbtree", "Bounding Box Tree and its label" ); // images of each interaction within events
  
  // allocate arrays
  // ---------------
  // allocate image vectors for planes
  m_planeImages = new std::vector<int>*[fNPlanes];
  for (int p=0; p<fNPlanes; p++) {
    m_planeImages[p] = new std::vector<int>;
  }
  m_bb_planeImages = new std::vector<int>*[fNPlanes];
  for (int p=0; p<fNPlanes; p++) {
    m_bb_planeImages[p] = new std::vector<int>;
  }
  // allocate image for PMT
  m_pmtImageHighGain = new std::vector<int>;
  m_pmtImageLowGain  = new std::vector<int>;
  
  // allocate vertex vector for each plane
  m_bb_3D_vertex_x = new std::vector< float >;
  m_bb_3D_vertex_y = new std::vector< float >;
  m_bb_3D_vertex_z = new std::vector< float >;
  m_bb_3D_vertex_t = new std::vector< float >;
  m_plane_bb_vertexpixel_wire = new std::vector<int>*[fNPlanes];
  for (int p=0; p<fNPlanes; p++) {
    m_plane_bb_vertexpixel_wire[p] = new std::vector<int>;
  }
  m_plane_bb_vertexpixel_time = new std::vector<int>;

  // Define ImageTree Branches
  // --------------------------
  // indexes
  m_ImageTree->Branch( "run", &m_run, "run/I" );
  m_ImageTree->Branch( "subrun", &m_subrun, "subrun/I" );
  m_ImageTree->Branch( "event", &m_event, "event/I" );
  // truths
  m_ImageTree->Branch( "Enu", &m_Enu, "Enu/F" );
  m_ImageTree->Branch( "mode", &m_mode, "mode/I" );
  m_ImageTree->Branch( "nuscatter", &m_nuscatter, "nuscatter/I" );
  m_ImageTree->Branch( "interaction", &m_interaction, "interaction/I" );
  m_ImageTree->Branch( "flavor", &m_flavor, "flavor/I" );
  m_ImageTree->Branch( "nticks", &m_nticks, "nticks/I" );
  char chr_mwires[20];
  sprintf( chr_mwires, "wires[%d]/I",fNPlanes );
  m_wires = new int[fNPlanes];
  m_ImageTree->Branch( "nwires", m_wires, chr_mwires );
  m_ImageTree->Branch( "label", m_label, "label[50]/C" );
  // bounding box info
  m_ImageTree->Branch( "nbboxes", &m_nfilledboxes, "nbboxes/I" );
  m_bbox_label = new std::vector<std::string>;
  m_ImageTree->Branch( "bblabels", m_bbox_label );
  
  // image branches
  for (int i=0; i<fNPlanes; i++) {
    char branchname[20];
    sprintf( branchname, "img_plane%d", i );
    m_ImageTree->Branch( branchname, &(*m_planeImages[i]) );
  }
  // pmt image branches
  m_ImageTree->Branch( "img_pmt_highgain", &(*m_pmtImageHighGain) );
  m_ImageTree->Branch( "img_pmt_lowgain", &(*m_pmtImageLowGain) );
  // vertex
  m_ImageTree->Branch( "bb_vertex_x", &(*m_bb_3D_vertex_x) );
  m_ImageTree->Branch( "bb_vertex_y", &(*m_bb_3D_vertex_y) );
  m_ImageTree->Branch( "bb_vertex_z", &(*m_bb_3D_vertex_z) );
  m_ImageTree->Branch( "bb_vertex_t", &(*m_bb_3D_vertex_t) );
  // vertex for each bb in terms of pixel position
  m_ImageTree->Branch( "bb_vertex_time", &(*m_plane_bb_vertexpixel_time) );
  for (int i=0; i<fNPlanes; i++) {
    char branchname[20];
    sprintf( branchname, "bb_plane%d_vertex_wire", i );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_vertexpixel_wire[i]) );
  }
  // bounding box info setup below
  
  
  // Define Bounding Box Tree Branches
  // -----------------------------------
  // indexes
  m_BBTree->Branch( "run", &m_run, "run/I" );
  m_BBTree->Branch( "subrun", &m_subrun, "subrun/I" );
  m_BBTree->Branch( "event", &m_event, "event/I" );
  m_BBTree->Branch( "nboxes", &m_nfilledboxes, "nboxes/I" );
  m_BBTree->Branch( "label", m_bblabel, "label[100]/C" );
  m_BBTree->Branch( "Enu", &m_Enu, "Enu/F" );
  for (int i=0; i<fNPlanes; i++) {
    char branchname[20];
    sprintf( branchname, "img_plane%d", i );
    m_BBTree->Branch( branchname, &(*m_bb_planeImages[i]) );
  }

  // Bounding Box Branches: one for each plane
  // We attach them to both ImageTree and BBTree
  // ugh, these branches are such bad code...
  m_plane_bb_loleft_t = new std::vector<int>*[fNPlanes];
  m_plane_bb_loleft_w = new std::vector<int>*[fNPlanes];
  m_plane_bb_loright_t = new std::vector<int>*[fNPlanes];
  m_plane_bb_loright_w = new std::vector<int>*[fNPlanes];
  m_plane_bb_hiright_t = new std::vector<int>*[fNPlanes];
  m_plane_bb_hiright_w = new std::vector<int>*[fNPlanes];
  m_plane_bb_hileft_t = new std::vector<int>*[fNPlanes];
  m_plane_bb_hileft_w = new std::vector<int>*[fNPlanes];
  m_plane_bbinteraction_loleft_t = new int[fNPlanes];
  m_plane_bbinteraction_loleft_w = new int[fNPlanes];
  m_plane_bbinteraction_hiright_t = new int[fNPlanes];
  m_plane_bbinteraction_hiright_w = new int[fNPlanes];
  for (int plane=0; plane<fNPlanes; plane++) {
    m_plane_bb_loleft_t[plane] = new std::vector<int>;
    m_plane_bb_loleft_w[plane] = new std::vector<int>;
    m_plane_bb_hileft_t[plane] = new std::vector<int>;
    m_plane_bb_hileft_w[plane] = new std::vector<int>;
    m_plane_bb_loright_t[plane] = new std::vector<int>;
    m_plane_bb_loright_w[plane] = new std::vector<int>;
    m_plane_bb_hiright_t[plane] = new std::vector<int>;
    m_plane_bb_hiright_w[plane] = new std::vector<int>;

    // set the ttree branch
    char branchname[100];

    sprintf( branchname, "LoLeft_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loleft_t[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_loleft_t[plane] );
    sprintf( branchname, "LoLeft_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loleft_w[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_loleft_w[plane] );

    sprintf( branchname, "LoRight_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loright_t[plane]) );
    sprintf( branchname, "LoRight_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_loright_w[plane]) );

    sprintf( branchname, "HiRight_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hiright_t[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_hiright_t[plane] );
    sprintf( branchname, "HiRight_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hiright_w[plane]) );
    m_BBTree->Branch( branchname, &m_plane_bbinteraction_hiright_w[plane] );

    sprintf( branchname, "HiLeft_t_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hileft_t[plane]) );
    sprintf( branchname, "HiLeft_w_plane%d", plane );
    m_ImageTree->Branch( branchname, &(*m_plane_bb_hileft_w[plane]) );
  }
}

void BNBCosmics::clearBoundingBoxes() {
  
  m_bbox_label->clear();
  m_bb_3D_vertex_x->clear();
  m_bb_3D_vertex_y->clear();
  m_bb_3D_vertex_z->clear();
  m_bb_3D_vertex_t->clear();
  m_plane_bb_vertexpixel_time->clear();
  for (int plane=0; plane<fNPlanes; plane++) {
    // bounding box points
    m_plane_bb_loleft_t[plane]->clear();
    m_plane_bb_loleft_w[plane]->clear();
    m_plane_bb_loright_t[plane]->clear();
    m_plane_bb_loright_w[plane]->clear();
    m_plane_bb_hiright_t[plane]->clear();
    m_plane_bb_hiright_w[plane]->clear();
    m_plane_bb_hileft_t[plane]->clear();
    m_plane_bb_hileft_w[plane]->clear();
    m_plane_bb_vertexpixel_wire[plane]->clear();
  }

}
  
void BNBCosmics::ExtractImage( const art::Event& e, const std::vector<larcaffe::RangeArray_t>& region_v, std::vector<int>& plane_compression ) {
  // puts the wire ADC data into ImageTree
  // returns the compression factors that was used to fit the data into the target image size
  //  we'll need those factors for the bounding box routines
  
  art::ServiceHandle<geo::Geometry> geom;
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  art::Handle< std::vector<recob::Wire> > wireVecHandle;
  // hit art handle would go here
  LoadDataHandles( e, digitVecHandle, wireVecHandle );
  
  // Now that data products ready, extract event image
  plane_compression.resize(fNPlanes+1,1);
  
  // Make an extractor
  larcaffe::supera::ImageExtractor extractor;
  _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__, __LINE__) << "[Cropping out Event Image]" << std::endl;
  
  // loop through cropping regions (should only be one for BNBCosmics Module)
  for(size_t range_index=0; range_index < region_v.size(); ++range_index) {
    
    auto const& range_v = region_v[range_index];
    
    if ( !larcaffe::RangesOK( range_v ) ) {
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Event Image Region was invalid!" << std::endl;
      larcaffe::PrintRangeArray( range_v );
      throw ::larcaffe::larbys();
    }
    
    auto const& time_range = range_v.back();
    
    for(size_t plane=0; plane < geom->Nplanes(); ++plane) {
      
      auto const& wire_range = range_v[plane];
      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__, __LINE__) << "fill wire range " << wire_range.start << " " << wire_range.end << std::endl;
      
      if(wire_range.start == wire_range.end && time_range.start == time_range.end) continue;
      
      // copy data into image
      larcaffe::Image img;
      if ( fImageSource=="Wire" )
	img = extractor.Extract( plane, wire_range, time_range, *wireVecHandle );
      else if ( fImageSource=="RawDigits" )
	img = extractor.Extract( plane, wire_range, time_range, *digitVecHandle );
      else
	throw ::larcaffe::larbys();
      
      m_nticks = time_range.size();
      m_wires[plane]  = wire_range.size();
      
      //check image
      // std::cout << "[Check Pre-Compressed Image]" << std::endl;
      // for (int t=0; t<(int)(time_range.end-time_range.start+1);t++) {
      //   std::cout << img.pixel( t, 1 ) << " ";
      // }
      // std::cout << std::endl;
      
      // filter: add the ability to reject images
      // bool keep = true;
      // for ( std::vector< larcaffe::supera::FilterBase* >::iterator it_filters=_filter_list.begin(); it_filters!=_filter_list.end(); it_filters++ ) {
      //   if( !(*it_filters)->doWeKeep( *db ) ) {
      //     keep = false;
      //     break;
      //   }
      // }
      // if ( !keep ) {
      //   continue;
      //}
      
      // compress image
      if ( _cropper.TargetWidth() < img.width() || _cropper.TargetHeight() < img.height() ) {
	plane_compression[plane] = img.width()/_cropper.TargetWidth();
	plane_compression[fNPlanes] = img.height()/_cropper.TargetHeight();
	img.compress( _cropper.TargetHeight(), _cropper.TargetWidth(), larcaffe::Image::kMaxPool );
      }
      
      // also need to transform vertex_tw into (time,wire) coordinates of this cropped image (filled already in getMC above)
      //m_vertex_tw.at(plane) = (int)(m_vertex_tw.at(plane)-wire_range.start)/plane_compression[plane];
      
      // std::cout << "[Check Compressed Image]" << std::endl;
      // for (int t=0; t<(int)(img.height());t++) {
      //   std::cout << img.pixel( t, 1 ) << " ";
      // }
      // std::cout << std::endl;
      
      
      // transfer image to ROOT variables
      m_planeImages[plane]->resize( img.height()*img.width() );
      for ( int w=0; w<(int)img.width(); w++) {
	for (int t=0; t<(int)img.height(); t++) {
	  m_planeImages[plane]->at( img.height()*w + t ) = (int)img.pixel( t, w );
	}
      }
      
      // std::cout << "[Check Plane Image]" << std::endl;
      // for (int t=0; t<(int)(img.height());t++) {
      //   std::cout << m_planeImages[plane]->at( img.height()*1+t);
      // }
      // std::cout << std::endl;	      
      
      
    	_logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) <<"image " << range_index << " @ " << plane << " extracted..." << std::endl;
    }//end of loop over planes
    
    // convert time coordinate
    //m_vertex_tw.at(fNPlanes) = (int)(m_vertex_tw.at(fNPlanes)-time_range.start)/plane_compression[fNPlanes];
    
  }// end of image crop ranges
}//end of ExtractImage
  
void BNBCosmics::LoadDataHandles( const art::Event& e,
				  art::Handle< std::vector<raw::RawDigit> >& digitVecHandle,
				  art::Handle< std::vector<recob::Wire> >& wireVecHandle ) {

  TStopwatch pWatchLArIO;
  
  // because LArSoft supposedly caches, we don't have to worry about repeatedly calling this
  if(_logger.info())
    _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Saving Event Image" << std::endl;
  
  // LOAD THE ADC VALUES
  if ( fImageSource=="RawDigits" ) {
    if(_producer_v[0].empty() || _producer_v[0]=="") {
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Producer not set for Rawdigits" << std::endl;
      throw ::larcaffe::larbys();
    }
    
    if(_logger.info())
      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Saving RawDigit... " << std::endl;
    
    pWatchLArIO.Start();
    e.getByLabel(_producer_v[0], digitVecHandle); 
    _time_prof_v[kIO_LARSOFT] += pWatchLArIO.RealTime();
    
    if ( !digitVecHandle.isValid() ) { // no rawdigits
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) 
	<< "Missing RawDigits by " << _producer_v[0] << " Skipping." << std::endl;
      throw ::larcaffe::larbys();
      return;
    }
  }
  else if ( fImageSource=="Wire" ) {
    if(_producer_v[1].empty() || _producer_v[1]=="") {
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Producer not set for Wire data" << std::endl;
      throw ::larcaffe::larbys();
    }
    
    if(_logger.info())
      _logger.LOG(::larcaffe::msg::kINFO,__FUNCTION__,__LINE__) << "Saving Wire ADC values... " << std::endl;
    
    pWatchLArIO.Start();
    e.getByLabel(_producer_v[1], wireVecHandle); 
    _time_prof_v[kIO_LARSOFT] += pWatchLArIO.RealTime();
    
    if ( !wireVecHandle.isValid() ) { // no rawdigits
      _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) 
	<< "Missing Wire by " << _producer_v[1] << " Skipping." << std::endl;
      throw ::larcaffe::larbys();
      return;
    }
  }//end of if producer==wire
  else if ( fImageSource=="Hit" ) {
    _logger.LOG(::larcaffe::msg::kCRITICAL,__FUNCTION__,__LINE__) << "Not implemented yet." << std::endl;
    throw ::larcaffe::larbys();
    return;
  }
}

void BNBCosmics::PreparePMTImage( const art::Event& evt ) {
  // we try to fit the PMT into 
  int imgwidth  = _cropper.TargetWidth();  // pmt number
  int imgheight = _cropper.TargetHeight(); // time

  art::Handle< std::vector< raw::OpDetWaveform > > hgHandle;
  art::Handle< std::vector< raw::OpDetWaveform > > lgHandle;
  evt.getByLabel( fOpDataModule, "OpdetBeamHighGain", hgHandle);
  evt.getByLabel( fOpDataModule, "OpdetBeamLowGain",  lgHandle);

  int nchannels = 32;
  int nticks = 1500;
  int tickblock = nticks/imgheight;
  int pedestal = 2047;
  
  // clear the image
  m_pmtImageHighGain->resize( imgheight*imgwidth, 0.0 );
  m_pmtImageLowGain->resize( imgheight*imgwidth, 0.0 );
  
  // we will tile PMT the data
  int ncopies = imgwidth/nchannels;

  // get trigger information
  art::ServiceHandle<util::TimeService> ts;
  float trig_timestamp = ts->TriggerTime();

  float dt_usec = wfm.TimeStamp()-trig_timestamp;
  

  // fill high gain image
  std::vector<raw::OpDetWaveform> const& hgwfms(*hgHandle);
  for (auto &wfm : hgwfms)  {
    int readout_ch = (int)wfm.ChannelNumber();
    int femch = readout_ch%100;
    if ( readout_ch%100>=nchannels )
      continue;
    
    // skip cosmic windows
    if ( wfm.size()<1000 )
      continue;
        //std::cout << " ch=" << readout_ch << " dt=" << dt_usec;
    
    int colindex = ncopies*femch;
    for (int timg=0; timg<imgheight; timg++) {
      int adcval = wfm.at( timg*tickblock )-pedestal;
      // maxpool the waveform
      for (int tb=1; tb<tickblock; tb++) {
	if ( wfm.at( timg*tickblock + tb )-pedestal>adcval )
	  adcval = wfm.at( timg*tickblock + tb )-pedestal;
      }
      // tile the data
      for ( int icpy=0; icpy<ncopies; icpy++ ) {
	int index = timg*imgwidth + colindex+icpy;
	m_pmtImageHighGain->at( index ) = adcval;
      }
    }
  }

  // fill low gain image
  std::vector<raw::OpDetWaveform> const& lgwfms(*lgHandle);
  for (auto &wfm : lgwfms)  {
    int readout_ch = (int)wfm.ChannelNumber();
    int femch = readout_ch%100;
    if ( readout_ch%100>=nchannels )
      continue;
    
    // skip cosmic windows
    if ( wfm.size()<1000 )
      continue;
    
    //float dt_usec = wfm.TimeStamp()-trig_timestamp;
    //std::cout << " ch=" << readout_ch << " dt=" << dt_usec;
    
    int colindex = ncopies*femch;
    for (int timg=0; timg<imgheight; timg++) {
      int adcval = wfm.at( timg*tickblock )-pedestal;
      // maxpool the waveform
      for (int tb=1; tb<tickblock; tb++) {
	if ( wfm.at( timg*tickblock + tb )-pedestal>adcval )
	  adcval = wfm.at( timg*tickblock + tb )-pedestal;
      }
      // tile the data
      for ( int icpy=0; icpy<ncopies; icpy++ ) {
	int index = timg*imgwidth + colindex+icpy;
	m_pmtImageLowGain->at( index ) = adcval;
      }
    }
  }
  
}

std::string BNBCosmics::labelBoundingBox( int key, const std::vector<larbys::supera::MCPTInfo>& bundle ) {
  if ( key<0 )
    return "neutrino";

  std::string label = "cosmic";
  for ( auto const& mcinfo : bundle ) {
    if ( (int)mcinfo.getID()==(int)mcinfo.getAncestorID() ) {
      // this is the root particle
      if ( std::abs(mcinfo.getPDG())==13 )
	label += "_muon";
      else if ( std::abs(mcinfo.getPDG())==2112 )
	label += "_neutron";
      else if ( std::abs(mcinfo.getPDG())==2212 )
	label += "_proton";
      else
	label += "_other";
    }
    else {
      if ( std::abs(mcinfo.getPDG())==11 && mcinfo.getProcess()=="Decay" ) {
	label += "_wedecay";
	return label;
      }
      else if ( std::abs(mcinfo.getPDG())==22 && mcinfo.getMother()==111 ) {
	label += "_wpizero";
	return label;
      }
    }
  }
  return label;
}

DEFINE_ART_MODULE(BNBCosmics)
