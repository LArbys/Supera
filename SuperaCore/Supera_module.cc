////////////////////////////////////////////////////////////////////////
// Class:       Supera
// Module Type: analyzer
// File:        Supera_module.cc
//
// Generated at Wed Dec 30 15:55:44 2015 by Taritree Wongjirad using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "Geometry/Geometry.h"
#include "RawData/RawDigit.h"

#include "db_lmdb.h"
#include "caffe.pb.h"
#include <cstring>

const size_t LMDB_MAP_SIZE = 1099511627776;  // 1 TB

class Supera;

class Supera : public art::EDAnalyzer {
public:
  explicit Supera(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  Supera(Supera const &) = delete;
  Supera(Supera &&) = delete;
  Supera & operator = (Supera const &) = delete;
  Supera & operator = (Supera &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  virtual void endJob();

private:

  // Declare member data here.
  db::LMDB* lmdb_;
  db::Transaction* txn_;
  int nfills_before_write;

};


Supera::Supera(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)  // ,
 // More initializers here.
{
  
  std::string dbname = p.get<std::string>("DatabaseName","output_supera.mdb");
  
  // open the database
  std::cout << "[Supera] Make Database: " << dbname << std::endl;
  lmdb_ = new db::LMDB();
  lmdb_->Open( dbname, db::NEW );
  std::cout << "[Supera] Create transaction. " << std::endl;
  txn_ = lmdb_->NewTransaction();
  nfills_before_write = 0;

}

void Supera::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  std::cout << "[Supera] Load RawDigits Handle" << std::endl;
  art::Handle< std::vector<raw::RawDigit> > digitVecHandle;
  e.getByLabel("daq", digitVecHandle);

  if ( !digitVecHandle.isValid() ) {
    std::cout << "Missing daq info. skipping." << std::endl;
    return;
  }

  // geometry service
  std::cout << "[Supera] Load Geometry Service" << std::endl;
  art::ServiceHandle<geo::Geometry> geom;

  // // data size
  const unsigned int nticks = 4800; // 2.4 ms at 2 MHz
  const unsigned int nwfms = 3456;  // collection plane size
  const unsigned int first_tick = 3200; // 1.6 ms from start of tpc acquisition
  const unsigned int first_col_wire = digitVecHandle->size() - nwfms; // a guess: fix this using geo service
  float* image = new float[nticks*nwfms];
  memset( image, 0, sizeof(float)*(nticks*nwfms) );
  std::cout << "[Supera] image array ready " << image[0] << std::endl;

  // Caffe Protobuf object which we will serialize and store
  caffe::Datum data;
  data.set_channels( 1 );          // number of planes (only collection for now)
  data.set_height( (int)nticks );  // number of ticks
  data.set_width( (int)nwfms );    // number of wires
  data.set_label( 0 );             // set label: how is this done?

  // loop over all wires
  std::cout << "[Supera] Store ADCs " << std::endl;
  for(size_t rdIter = 0; rdIter < digitVecHandle->size(); ++rdIter){
    art::Ptr<raw::RawDigit> digitVec(digitVecHandle, rdIter);
    geo::View_t view = geom->View( digitVec->Channel() );
    if ( view==geo::kZ ) {
      // select collection plane
      int idx_ch = digitVec->Channel()-first_col_wire;
      if ( idx_ch<0 || idx_ch>=(int)nwfms )
  	continue; // out of range, skip
      for (unsigned int t=first_tick; t<first_tick+nticks; t++) {
  	//int index = nwfms*(t-first_tick) + idx_ch; // row major
  	//data.set_float_data( index, (float)digitVec->ADC(t) );
	int idx_t = t-first_tick;
  	image[idx_t*nwfms + idx_ch] = (float)digitVec->ADC(t);
      }
    }	
  }
  
  // copy into Datum
  std::cout << "[Supera] Copy into protobuf " << std::endl;
  for (unsigned int t=0; t<nticks; t++) {
    for (unsigned int ch=0; ch<nwfms; ch++) {
      data.add_float_data( image[t*nwfms+ch] );
    }
  }
  
  // now serialize and store
  std::cout << "[Supera] Serialize " << std::endl;
  std::string out;
  data.SerializeToString(&out);
  char eventid[100];
  sprintf( eventid, "run%06d_subrun%04d_event%06d", e.run(), e.subRun(), e.event() );
  std::string key_str = eventid;
  std::cout << "[Supera] Store in DB " << std::endl;
  txn_->Put(key_str, out);
  nfills_before_write++;
  if ( nfills_before_write==100 ) {
    txn_->Commit();
    delete txn_;
    txn_ = lmdb_->NewTransaction();
  }

  delete [] image;
}


void Supera::endJob() {
  txn_->Commit();
}


DEFINE_ART_MODULE(Supera)
